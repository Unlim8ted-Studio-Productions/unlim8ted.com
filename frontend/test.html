<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Serverless WebRTC Multiplayer (Multi-Guest, Encrypted Links)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#0f1520; --line:#223041; --txt:#e7eef7; --mut:#9bb0c6;
      --ok:#2a6b3a; --warn:#6b5a2a; --bad:#6b2a2a; --btn:#121c2a; --btnh:#152238;
    }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display:grid; grid-template-columns: 430px 1fr; height:100%; }
    .panel { padding:16px; border-right:1px solid #18212b; overflow:auto; background:linear-gradient(180deg, #0b0f14, #070a0e); }
    .card { background:var(--panel); border:1px solid var(--line); border-radius:16px; padding:14px; margin:12px 0; }
    h1 { font-size:16px; margin:0 0 10px; }
    h2 { font-size:13px; margin:0 0 8px; color:var(--mut); font-weight:600; letter-spacing:.2px;}
    .small { font-size:12px; color:var(--mut); line-height:1.4; }
    label { display:block; font-size:12px; color:var(--mut); margin:10px 0 6px; }
    input, textarea, button {
      width:100%; box-sizing:border-box; border-radius:14px; border:1px solid var(--line);
      background:var(--panel); color:var(--txt); padding:10px 12px; font-size:14px;
    }
    textarea { min-height:84px; resize:vertical; }
    button { cursor:pointer; border:1px solid #2b3d55; background:var(--btn); }
    button:hover { background:var(--btnh); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid var(--line); background:var(--panel); font-size:12px; }
    .ok { border-color:var(--ok); }
    .warn { border-color:var(--warn); }
    .bad { border-color:var(--bad); }
    .status { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .game { position:relative; }
    canvas { display:block; width:100%; height:100%; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap;
           background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:10px; color:#cfe0ff; }
    .inlineBtn { width:auto; padding:9px 12px; }
    .inline { display:flex; gap:10px; align-items:center; }
    .hidden { display:none !important; }
    .bigAction { font-size:15px; padding:12px 14px; border-radius:16px; }
    .copyRow { display:grid; grid-template-columns:1fr auto; gap:10px; }
    .hint { margin-top:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Serverless WebRTC Multiplayer (Host + Multiple Guests)</h1>
      <div class="small">
        No server. No time pressure. Links can be sent whenever.
        <br/>Host invites guests <b>one-at-a-time</b> (each guest has their own offer/answer).
      </div>

      <div class="card">
        <h2>Room Passphrase (required)</h2>
        <div class="small">This encrypts the offer/answer links. Everyone must use the exact same passphrase.</div>
        <label>Passphrase</label>
        <input id="pass" type="password" placeholder="long + unique (e.g. cobalt-otter-99-river-lamp)" autocomplete="off"/>
        <div class="hint small">Tip: Use a long phrase. If auth fails, it’s almost always a mismatch.</div>
      </div>

      <div class="card" id="modeCard">
        <h2>Choose your role</h2>
        <div class="row">
          <button id="beHost" class="bigAction">I’m the Host</button>
          <button id="beGuest" class="bigAction">I’m a Guest</button>
        </div>
      </div>

      <!-- HOST WIZARD -->
      <div class="card hidden" id="hostCard">
        <h2 id="hostTitle">Host</h2>

        <!-- Host step A: create invite -->
        <div id="hostStepInvite">
          <div class="small">
            Create an invite for the <b>next guest</b>. Send them the offer link. There is <b>no expiry</b>.
          </div>
          <button id="hostCreateInvite" class="bigAction" style="margin-top:10px;">Create Invite for Next Guest</button>

          <div class="hidden" id="hostOfferBox" style="margin-top:12px;">
            <label>Offer link to send to guest</label>
            <div class="copyRow">
              <textarea id="hostOfferOut" readonly></textarea>
              <button id="copyOffer" class="inlineBtn">Copy</button>
            </div>
            <div class="small hint">Send this to exactly one guest. Then wait as long as you want for their answer.</div>
          </div>
        </div>

        <!-- Host step B: waiting for answer -->
        <div class="hidden" id="hostStepWait">
          <div class="small">
            When your guest sends back an <b>Answer link</b>, paste it below and apply it.
          </div>
          <label>Paste guest’s Answer link here</label>
          <textarea id="hostAnswerIn" placeholder="…#answer.XXXX"></textarea>

          <div class="row" style="margin-top:10px;">
            <button id="hostApplyAnswer" class="bigAction">Apply Answer (Connect Guest)</button>
            <button id="hostBackToInvite">Invite Another Guest</button>
          </div>

          <div class="small hint">
            If you need to invite a different guest instead, click “Invite Another Guest” — it doesn’t break existing guests.
          </div>
        </div>

        <div class="status" id="hostStatus"></div>
      </div>

      <!-- GUEST WIZARD -->
      <div class="card hidden" id="guestCard">
        <h2 id="guestTitle">Guest</h2>

        <!-- Guest step A: has offer -->
        <div id="guestStepOffer">
          <div class="small">
            Paste the host’s <b>Offer link</b>, generate an Answer link, and send it back. No rush.
          </div>
          <label>Paste Host Offer link</label>
          <textarea id="guestOfferIn" placeholder="…#offer.XXXX"></textarea>

          <button id="guestMakeAnswer" class="bigAction" style="margin-top:10px;">Generate Answer Link</button>

          <div class="hidden" id="guestAnswerBox" style="margin-top:12px;">
            <label>Answer link to send back to Host</label>
            <div class="copyRow">
              <textarea id="guestAnswerOut" readonly></textarea>
              <button id="copyAnswer" class="inlineBtn">Copy</button>
            </div>
            <div class="small hint">Send this to the Host. Once they apply it, you’ll connect automatically.</div>
          </div>
        </div>

        <!-- Guest step B: waiting -->
        <div class="hidden" id="guestStepWait">
          <div class="small">Waiting for Host to apply your answer… keep this page open.</div>
        </div>

        <div class="status" id="guestStatus"></div>
      </div>

      <div class="card">
        <h2>Quick checks</h2>
        <div class="small">
          If it doesn’t connect:
          <ul>
            <li>Try phone hotspot (some networks block P2P).</li>
            <li>Confirm passphrase matches exactly.</li>
            <li>Make sure host pasted an <b>answer</b>, guest pasted an <b>offer</b>.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h2>Log</h2>
        <div class="log" id="log"></div>
      </div>
    </div>

    <div class="game">
      <canvas id="c"></canvas>
    </div>
  </div>

<script>
/* =========================
   Helpers / UI
========================= */
const el = (id) => document.getElementById(id);
const logEl = el("log");
function log(...args){
  const s = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
  logEl.textContent = (logEl.textContent + "\n" + s).trim();
  logEl.scrollTop = logEl.scrollHeight;
}
function show(id, on=true){ el(id).classList.toggle("hidden", !on); }
function setStatus(boxId, items){
  const box = el(boxId);
  box.innerHTML = "";
  items.forEach(it=>{
    const d = document.createElement("div");
    d.className = `pill ${it.kind||""}`;
    d.textContent = it.text;
    box.appendChild(d);
  });
}
async function copyText(text){
  try { await navigator.clipboard.writeText(text); return true; }
  catch { return false; }
}
function requirePass(){
  const pass = el("pass").value;
  if (!pass){ alert("Set a room passphrase first."); return null; }
  return pass;
}

/* =========================
   Crypto: AES-GCM signaling
========================= */
function b64urlEncodeBytes(bytes){
  let bin = ""; bytes.forEach(b => bin += String.fromCharCode(b));
  return btoa(bin).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"");
}
function b64urlDecodeToBytes(b64url){
  const b64 = b64url.replace(/-/g,"+").replace(/_/g,"/") + "===".slice((b64url.length + 3) % 4);
  const bin = atob(b64);
  return new Uint8Array([...bin].map(ch => ch.charCodeAt(0)));
}
async function deriveKey(pass, salt){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(pass), { name:"PBKDF2" }, false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name:"PBKDF2", salt, iterations: 150000, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length: 256 },
    false, ["encrypt","decrypt"]
  );
}
async function encryptJsonToB64url(pass, obj){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv   = crypto.getRandomValues(new Uint8Array(12));
  const key  = await deriveKey(pass, salt);
  const pt   = new TextEncoder().encode(JSON.stringify(obj));
  const ct   = new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, pt));
  const packed = new Uint8Array(salt.length + iv.length + ct.length);
  packed.set(salt,0); packed.set(iv,16); packed.set(ct,28);
  return b64urlEncodeBytes(packed);
}
async function decryptB64urlToJson(pass, packedB64url){
  const packed = b64urlDecodeToBytes(packedB64url);
  const salt = packed.slice(0,16);
  const iv   = packed.slice(16,28);
  const ct   = packed.slice(28);
  const key  = await deriveKey(pass, salt);
  const pt   = new Uint8Array(await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct));
  return JSON.parse(new TextDecoder().decode(pt));
}
function makeSignalLink(type, payload){
  return `${location.origin}${location.pathname}#${type}.${payload}`;
}
function parseSignalHash(hash){
  const h = hash.startsWith("#") ? hash.slice(1) : hash;
  const [type, payload] = h.split(".", 2);
  if (!type || !payload) return null;
  if (type !== "offer" && type !== "answer") return null;
  return { type, payload };
}

/* =========================
   WebRTC core (multi-guest)
   Host keeps many PeerConnections:
   - one PC per guestId
   - one DataChannel per PC
========================= */
const ICE_SERVERS = [{ urls:"stun:stun.l.google.com:19302" }];

function waitForIceGatheringComplete(pc){
  if (pc.iceGatheringState === "complete") return Promise.resolve();
  return new Promise((resolve)=>{
    const on = () => {
      if (pc.iceGatheringState === "complete"){
        pc.removeEventListener("icegatheringstatechange", on);
        resolve();
      }
    };
    pc.addEventListener("icegatheringstatechange", on);
  });
}

let mode = "none"; // host | guest
const myId = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);

// HOST state
let inviteCounter = 0;
let pendingInvite = null; // {inviteId, pc, dc}
const hostPeers = new Map(); // guestId -> {pc, dc, authOk, lastInput}

// GUEST state
let guestPc = null;
let guestDc = null;
let guestAuthOk = false;
let hostId = null;

/* =========================
   Auth handshake (passphrase proof)
   - DTLS already encrypts DataChannel.
   - This handshake blocks wrong-pass peers early.
========================= */
async function sha256Hex(str){
  const b = new TextEncoder().encode(str);
  const d = new Uint8Array(await crypto.subtle.digest("SHA-256", b));
  return [...d].map(x => x.toString(16).padStart(2,"0")).join("");
}
async function sendAuthHello(dc){
  const pass = el("pass").value;
  const nonce = crypto.getRandomValues(new Uint32Array(2));
  const nonceStr = `${nonce[0].toString(16)}${nonce[1].toString(16)}`;
  const token = await sha256Hex(pass + "|" + nonceStr);
  dc.send(JSON.stringify({ t:"auth_hello", from: myId, nonce: nonceStr, token }));
}
async function handleAuthHello(msg, replyDc){
  const pass = el("pass").value;
  const expected = await sha256Hex(pass + "|" + msg.nonce);
  if (expected !== msg.token){
    log("AUTH FAILED from peer (wrong pass). Closing peer.");
    try { replyDc.close(); } catch {}
    return false;
  }
  replyDc.send(JSON.stringify({ t:"auth_ok", from: myId }));
  return true;
}

/* =========================
   HOST: create invite offer for next guest
   - Each invite is for ONE guest.
========================= */
async function hostCreateInvite(){
  const pass = requirePass(); if (!pass) return;

  // Clean up any previous pending invite (if never used)
  if (pendingInvite?.pc){
    try { pendingInvite.dc?.close(); } catch {}
    try { pendingInvite.pc.close(); } catch {}
  }

  inviteCounter++;
  const inviteId = `inv${inviteCounter}-${Date.now()}`;

  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  const dc = pc.createDataChannel("game", { ordered:false, maxRetransmits:0 });

  dc.onopen = async () => {
    log("Host DC open for pending invite:", inviteId);
    await sendAuthHello(dc);
    updateHostStatus();
  };
  dc.onclose = () => { log("Host DC closed (invite):", inviteId); updateHostStatus(); };
  dc.onmessage = (e) => hostOnMessage(inviteId, e.data);

  pc.onconnectionstatechange = () => {
    log("Host PC state (invite)", inviteId, "=", pc.connectionState);
    updateHostStatus();
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await waitForIceGatheringComplete(pc);

  const payload = await encryptJsonToB64url(pass, {
    v:1, inviteId, hostId: myId, desc: pc.localDescription
  });

  pendingInvite = { inviteId, pc, dc, authOk:false, guestId:null };
  const link = makeSignalLink("offer", payload);

  el("hostOfferOut").value = link;
  show("hostOfferBox", true);

  // Wizard: now show waiting step
  show("hostStepInvite", false);
  show("hostStepWait", true);

  log("Host created offer invite:", inviteId);
  updateHostStatus();
}

/* =========================
   HOST: apply guest answer to connect
========================= */
async function hostApplyAnswer(){
  const pass = requirePass(); if (!pass) return;
  if (!pendingInvite?.pc){ alert("Create an invite first."); return; }

  const txt = el("hostAnswerIn").value.trim();
  const hash = txt.includes("#") ? txt.slice(txt.indexOf("#")) : txt;
  const parsed = parseSignalHash(hash);
  if (!parsed || parsed.type !== "answer"){
    alert("Paste a valid Answer link (…#answer.XXXX).");
    return;
  }

  let obj;
  try { obj = await decryptB64urlToJson(pass, parsed.payload); }
  catch { alert("Could not decrypt answer. Wrong passphrase or corrupted link."); return; }

  if (!obj?.inviteId || !obj?.guestId || !obj?.desc){
    alert("Answer payload missing fields.");
    return;
  }
  if (obj.inviteId !== pendingInvite.inviteId){
    alert("This answer is for a different invite. Ask the guest for the matching answer link.");
    return;
  }

  // Apply answer
  await pendingInvite.pc.setRemoteDescription(obj.desc);

  // Promote pending invite to active peer
  pendingInvite.guestId = obj.guestId;
  hostPeers.set(obj.guestId, pendingInvite);

  log("Host connected guest:", obj.guestId, "for", obj.inviteId);

  // Reset wizard to invite next guest (but keep peers connected)
  el("hostAnswerIn").value = "";
  show("hostStepWait", false);
  show("hostStepInvite", true);
  show("hostOfferBox", false);
  pendingInvite = null;

  updateHostStatus();
}

/* =========================
   HOST: per-peer message handling
========================= */
const hostPlayerInputs = new Map(); // guestId -> input state
function hostOnMessage(inviteId, data){
  let msg;
  try { msg = JSON.parse(data); } catch { return; }

  // Find which peer this message belongs to
  // (pending invite uses inviteId, active uses guestId map)
  let peer = null;
  if (pendingInvite && pendingInvite.inviteId === inviteId) peer = pendingInvite;
  // If active, we don't know inviteId (messages still come in on dc); so fallback below:
  if (!peer){
    // find by matching datachannel reference is hard here, so we embed guestId in messages.
    // We'll rely on msg.from for routing.
    peer = hostPeers.get(msg.from);
  }

  if (msg.t === "auth_hello"){
    // verify passphrase match; on success, mark authOk
    (async()=>{
      const ok = await handleAuthHello(msg, (peer?.dc));
      if (!ok) return;

      if (peer){
        peer.authOk = true;
        // Tell host the guestId if it's pending
        if (!peer.guestId) peer.guestId = msg.from;
        log("Host auth ok with:", msg.from);
        updateHostStatus();
      }
    })();
    return;
  }

  if (msg.t === "auth_ok"){
    // Guest acknowledged our hello
    if (peer){
      peer.authOk = true;
      if (!peer.guestId) peer.guestId = msg.from;
      log("Host auth confirmed by:", msg.from);
      updateHostStatus();
    }
    return;
  }

  if (msg.t === "input" && msg.from){
    // rate limit basic
    hostPlayerInputs.set(msg.from, msg.inp);
    return;
  }

  if (msg.t === "chat" && msg.from){
    log(`[guest ${msg.from}] ${msg.text}`);
    return;
  }
}

function hostBroadcast(obj){
  const s = JSON.stringify(obj);
  for (const [guestId, p] of hostPeers){
    if (p?.dc?.readyState === "open" && p.authOk){
      p.dc.send(s);
    }
  }
}

/* =========================
   GUEST: process offer -> create answer link
========================= */
async function guestGenerateAnswer(){
  const pass = requirePass(); if (!pass) return;

  const txt = el("guestOfferIn").value.trim() || location.href;
  const hash = txt.includes("#") ? txt.slice(txt.indexOf("#")) : txt;
  const parsed = parseSignalHash(hash);
  if (!parsed || parsed.type !== "offer"){
    alert("Paste a valid Offer link (…#offer.XXXX).");
    return;
  }

  let obj;
  try { obj = await decryptB64urlToJson(pass, parsed.payload); }
  catch { alert("Could not decrypt offer. Wrong passphrase or corrupted link."); return; }

  if (!obj?.inviteId || !obj?.hostId || !obj?.desc){
    alert("Offer payload missing fields.");
    return;
  }

  // Build guest PC
  if (guestPc){
    try { guestDc?.close(); } catch {}
    try { guestPc.close(); } catch {}
  }
  hostId = obj.hostId;

  guestPc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  guestAuthOk = false;

  guestPc.ondatachannel = (e) => {
    guestDc = e.channel;
    guestDc.onopen = async () => {
      log("Guest DC open. Sending auth hello…");
      await sendAuthHello(guestDc);
      updateGuestStatus();
      // wizard: waiting for host to apply answer / finish connect
      show("guestStepOffer", false);
      show("guestStepWait", true);
    };
    guestDc.onclose = () => { log("Guest DC closed."); updateGuestStatus(); };
    guestDc.onmessage = (ev) => guestOnMessage(ev.data);
  };

  guestPc.onconnectionstatechange = () => {
    log("Guest PC state =", guestPc.connectionState);
    updateGuestStatus();
  };

  await guestPc.setRemoteDescription(obj.desc);
  const answer = await guestPc.createAnswer();
  await guestPc.setLocalDescription(answer);
  await waitForIceGatheringComplete(guestPc);

  const payload = await encryptJsonToB64url(pass, {
    v:1, inviteId: obj.inviteId, guestId: myId, desc: guestPc.localDescription
  });
  const answerLink = makeSignalLink("answer", payload);

  el("guestAnswerOut").value = answerLink;
  show("guestAnswerBox", true);

  log("Guest generated answer for invite:", obj.inviteId);
  updateGuestStatus();
}

async function guestOnMessage(data){
  let msg;
  try { msg = JSON.parse(data); } catch { return; }

  if (msg.t === "auth_hello"){
    const ok = await handleAuthHello(msg, guestDc);
    if (ok){
      guestAuthOk = true;
      log("Guest auth ok with host.");
      updateGuestStatus();
    }
    return;
  }
  if (msg.t === "auth_ok"){
    guestAuthOk = true;
    log("Guest auth confirmed by host.");
    updateGuestStatus();
    return;
  }

  // Game snapshots from host
  if (msg.t === "state"){
    onStateSnapshot(msg);
    return;
  }
  if (msg.t === "chat"){
    log(`[host] ${msg.text}`);
    return;
  }
}

/* =========================
   Game: Host authoritative, multi guests
========================= */
const canvas = el("c");
const ctx = canvas.getContext("2d");
function resize(){
  const r = canvas.getBoundingClientRect();
  canvas.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
  canvas.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
}
addEventListener("resize", resize); resize();

const SPEED = 240;
const SNAP_HZ = 20;
let lastTime = performance.now();
let snapAcc = 0;

const players = new Map(); // id -> {x,y,targetX,targetY,_lastInp}
function ensurePlayer(id){
  if (!players.has(id)){
    players.set(id, {
      id,
      x: 160 + Math.random()*260,
      y: 160 + Math.random()*260,
      targetX: null,
      targetY: null,
      _lastInp: {up:false,down:false,left:false,right:false}
    });
  }
  return players.get(id);
}
ensurePlayer(myId);

let inputState = { up:false, down:false, left:false, right:false };
function setKey(e, down){
  const k = e.key.toLowerCase();
  if (k === "w" || k === "arrowup") inputState.up = down;
  if (k === "s" || k === "arrowdown") inputState.down = down;
  if (k === "a" || k === "arrowleft") inputState.left = down;
  if (k === "d" || k === "arrowright") inputState.right = down;
}
addEventListener("keydown", (e)=> setKey(e, true));
addEventListener("keyup",   (e)=> setKey(e, false));

function computeVel(inp){
  let vx=0, vy=0;
  if (inp.left) vx -= 1;
  if (inp.right) vx += 1;
  if (inp.up) vy -= 1;
  if (inp.down) vy += 1;
  const len = Math.hypot(vx,vy);
  if (len>0){ vx/=len; vy/=len; }
  return {vx,vy};
}
function simStep(p, dt, inp){
  const v = computeVel(inp);
  p.x += v.vx * SPEED * dt;
  p.y += v.vy * SPEED * dt;

  const W = canvas.width / devicePixelRatio;
  const H = canvas.height / devicePixelRatio;
  p.x = Math.max(20, Math.min(W-20, p.x));
  p.y = Math.max(20, Math.min(H-20, p.y));
}

function hostSimAndBroadcast(dt){
  // Host simulates ALL players using last-known inputs
  // Host's own player uses local inputState.
  for (const [id, p] of players){
    const inp = (id === myId) ? inputState : (hostPlayerInputs.get(id) || p._lastInp || {up:false,down:false,left:false,right:false});
    p._lastInp = inp;
    simStep(p, dt, inp);
  }

  snapAcc += dt;
  const snapInterval = 1 / SNAP_HZ;
  if (snapAcc >= snapInterval){
    snapAcc %= snapInterval;
    const snapshot = [];
    for (const [id,p] of players){
      snapshot.push({ id, x:p.x, y:p.y });
    }
    hostBroadcast({ t:"state", snapshot, time: performance.now() });
  }
}

function guestSendInputs(){
  if (!guestDc || guestDc.readyState !== "open" || !guestAuthOk) return;
  // basic send; you can throttle if you want
  guestDc.send(JSON.stringify({ t:"input", from: myId, inp: inputState, time: performance.now() }));
}

function onStateSnapshot(msg){
  // Everyone (guest side) updates targets for interpolation
  for (const s of msg.snapshot){
    const p = ensurePlayer(s.id);
    if (mode === "guest" && s.id === myId){
      // gentle reconciliation
      p.x += (s.x - p.x) * 0.12;
      p.y += (s.y - p.y) * 0.12;
    } else {
      p.targetX = s.x;
      p.targetY = s.y;
    }
  }
}

function interpolateRemotes(dt){
  for (const [id, p] of players){
    if (id === myId) continue;
    if (p.targetX != null){
      const alpha = 1 - Math.pow(0.0001, dt);
      p.x += (p.targetX - p.x) * alpha;
      p.y += (p.targetY - p.y) * alpha;
    }
  }
}

function render(){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.scale(devicePixelRatio, devicePixelRatio);
  const W = w/devicePixelRatio, H = h/devicePixelRatio;

  // grid
  ctx.globalAlpha = 0.35;
  ctx.beginPath();
  for (let x=0; x<=W; x+=40){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
  for (let y=0; y<=H; y+=40){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  ctx.strokeStyle = "#1a2431";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.globalAlpha = 1;

  // players
  for (const [id,p] of players){
    const isMe = (id === myId);
    ctx.beginPath();
    ctx.arc(p.x,p.y,14,0,Math.PI*2);
    ctx.fillStyle = isMe ? "#e7eef7" : "#7fb3ff";
    ctx.fill();

    ctx.font = "12px system-ui";
    ctx.fillStyle = "#cfe0ff";
    const label = isMe ? `you (${mode})` : (mode==="host" ? "guest" : "peer");
    ctx.fillText(label, p.x + 18, p.y + 4);
  }

  // HUD
  ctx.fillStyle = "#e7eef7";
  ctx.font = "13px system-ui";
  const peerCount = (mode==="host") ? hostPeers.size : 1;
  const hud = `mode: ${mode}  |  you: ${myId}  |  peers: ${peerCount}`;
  ctx.fillText(hud, 14, 20);

  ctx.restore();
}

function loop(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;

  ensurePlayer(myId);

  // Local prediction
  simStep(players.get(myId), dt, inputState);

  if (mode === "host"){
    // Ensure all connected guests exist as players
    for (const [guestId, peer] of hostPeers){
      ensurePlayer(guestId);
    }
    // Simulate & broadcast
    hostSimAndBroadcast(dt);
  } else if (mode === "guest"){
    guestSendInputs();
    interpolateRemotes(dt);
  }

  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =========================
   Status + Wizard controls
========================= */
function updateHostStatus(){
  const items = [];
  items.push({ text:`You: ${myId}`, kind:"ok" });
  items.push({ text:`Guests connected: ${hostPeers.size}`, kind: hostPeers.size>0 ? "ok" : "warn" });
  items.push({ text:`Pending invite: ${pendingInvite ? pendingInvite.inviteId : "none"}`, kind: pendingInvite ? "warn" : "ok" });

  // show per-guest quick states (collapsed into pills)
  for (const [gid, p] of hostPeers){
    const st = p.pc?.connectionState || "unknown";
    const dc = p.dc?.readyState || "unknown";
    const kind = (st==="connected" && dc==="open" && p.authOk) ? "ok" : "warn";
    items.push({ text:`${gid}: ${st}/${dc}${p.authOk ? "" : " (auth…)"}`, kind });
  }

  setStatus("hostStatus", items);
}
function updateGuestStatus(){
  const items = [];
  items.push({ text:`You: ${myId}`, kind:"ok" });
  items.push({ text:`Host: ${hostId || "unknown"}`, kind: hostId ? "ok" : "warn" });
  items.push({ text:`WebRTC: ${guestPc?.connectionState || "idle"}`, kind: guestPc?.connectionState==="connected" ? "ok" : "warn" });
  items.push({ text:`DataChannel: ${guestDc?.readyState || "idle"}`, kind: guestDc?.readyState==="open" ? "ok" : "warn" });
  items.push({ text:`Auth: ${guestAuthOk ? "ok" : "pending"}`, kind: guestAuthOk ? "ok" : "warn" });
  setStatus("guestStatus", items);
}

function setMode(newMode){
  mode = newMode;
  show("modeCard", false);

  if (mode === "host"){
    show("hostCard", true);
    show("guestCard", false);
    show("hostStepInvite", true);
    show("hostStepWait", false);
    show("hostOfferBox", false);
    updateHostStatus();
    log("Mode = host");
  } else {
    show("hostCard", false);
    show("guestCard", true);
    show("guestStepOffer", true);
    show("guestStepWait", false);
    show("guestAnswerBox", false);
    updateGuestStatus();
    log("Mode = guest");
  }
}

el("beHost").onclick = () => setMode("host");
el("beGuest").onclick = () => setMode("guest");

el("hostCreateInvite").onclick = hostCreateInvite;
el("hostApplyAnswer").onclick = hostApplyAnswer;
el("hostBackToInvite").onclick = () => {
  // allow skipping waiting; keep pending invite (offer link) visible
  show("hostStepWait", false);
  show("hostStepInvite", true);
  show("hostOfferBox", pendingInvite != null);
};

el("guestMakeAnswer").onclick = guestGenerateAnswer;

// Copy buttons
el("copyOffer").onclick = async () => {
  const ok = await copyText(el("hostOfferOut").value);
  if (!ok) alert("Copy failed. Long-press and copy manually.");
};
el("copyAnswer").onclick = async () => {
  const ok = await copyText(el("guestAnswerOut").value);
  if (!ok) alert("Copy failed. Long-press and copy manually.");
};

// Auto-fill offer/answer if page opened with hash
(function autoFillFromHash(){
  const parsed = parseSignalHash(location.hash);
  if (!parsed) return;
  // Don’t show all steps; just put link in the right box once user chooses mode.
  const full = location.href;
  // Heuristic: if it’s an offer, likely guest; if answer, likely host.
  if (parsed.type === "offer"){
    log("Detected OFFER link in URL. Choose Guest mode, then generate Answer.");
    el("guestOfferIn").value = full;
  } else {
    log("Detected ANSWER link in URL. Choose Host mode, then apply Answer.");
    el("hostAnswerIn").value = full;
  }
})();
</script>
</body>
</html>
