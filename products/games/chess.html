<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unlim8ted Chess</title>
  <meta property="og:title" content="Unlim8ted Chess" />
  <meta name="description"
    content="Play chess against different difficulties of AI. Watch AI play against itself. Learn to play chess. Customizable visuals. Unlim8ted Chess — always free, no sign up required. Powered by Unlim8ted Studio Productions." />

  <script type="module" src="https://unlim8ted.com/components/site-navbar.js"></script>
  <script type="module">
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { collection, doc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
    import { getFirebase } from "/components/firebase-init.js";
    const { auth, db } = getFirebase();
  </script>

  <style>
    :root{
      --bg: #0b0f17;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --line: rgba(255,255,255,0.10);
      --accent: #39c891;
      --accent2:#7c5cff;
      --danger:#ff5c7a;

      --board-light:#f0d9b5;
      --board-dark:#b58863;
      --hl-last: rgba(57,200,145,0.35);
      --hl-selected: rgba(124,92,255,0.40);
      --hl-check: rgba(255,92,122,0.45);
      --dot: rgba(0,0,0,0.18);
      --dot-capture: rgba(0,0,0,0.28);

      --radius: 16px;
      --radius2: 12px;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --shadow2: 0 8px 22px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family:var(--ui);
      color:var(--text);
      background:
        radial-gradient(1100px 700px at 20% 10%, rgba(124,92,255,.28), transparent 60%),
        radial-gradient(900px 650px at 90% 15%, rgba(57,200,145,.22), transparent 55%),
        radial-gradient(900px 700px at 50% 100%, rgba(255,92,122,.10), transparent 60%),
        var(--bg);
      padding: 16px;
    }
.board{grid-template-rows: repeat(8, 1fr);
 
  width: min(560px, 86vw);
  height: min(560px, 86vw);     /* force square */
  aspect-ratio: auto;          /* not needed anymore */
  display:grid;
  grid-template-columns: repeat(8, 1fr);
  border-radius: 18px;
  overflow:hidden;
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow: 0 22px 70px rgba(0,0,0,.40);
  margin: 0 auto;
  background: rgba(255,255,255,0.04);
  position: relative;
  user-select:none;
  touch-action: manipulation;
}
.board-card{ overflow: hidden; }
/* piece colors (emoji text color) */
.sq{
  color: var(--white-piece);
  text-shadow: 0 1px 0 rgba(0,0,0,.25);
}
.sq.black-piece{
  color: var(--black-piece);
  text-shadow: 0 1px 0 rgba(0,0,0,.35);
}

/* default theme piece colors */
:root{
  --white-piece: rgba(255,255,255,.95);
  --black-piece: rgba(10,10,12,.92);
}

    .app{
      max-width: 1100px;
      margin: 0 auto;
      padding-top: 70px;
    }

    /* Modern glass panels */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.05));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }

    /* Top HUD */
    .hud{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px;
      margin-bottom: 14px;
    }
    .hud-left{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 0;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }
    .brand b{letter-spacing:.2px}
    .pill{
      font-size:12px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill strong{color:var(--text); font-weight:700}
    .hud-right{
      display:flex;
      align-items:center;
      gap:10px;
    }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
      font-weight: 650;
      letter-spacing: .15px;
    }
    button:hover{
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.18);
      transform: translateY(-1px);
    }
    button:active{transform: translateY(0px) scale(.99)}
    button.primary{
      border-color: rgba(57,200,145,0.45);
      background: rgba(57,200,145,0.18);
    }
    button.primary:hover{background: rgba(57,200,145,0.26)}
    button.ghost{
      background: transparent;
      border-color: rgba(255,255,255,0.14);
    }
    .icon-btn{
      width: 42px;
      height: 42px;
      display:grid;
      place-items:center;
      padding:0;
      border-radius: 14px;
    }
    .icon{
      width: 20px; height: 20px;
      display:block;
      fill: currentColor;
    }

    /* Layout */
    .grid{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 14px;
      align-items:start;
    }

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
    }

    /* Board card */
    .board-card{
      padding: 14px;
    }

    .board-wrap{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .board{
      width: min(560px, 86vw);
      aspect-ratio: 1 / 1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 22px 70px rgba(0,0,0,.40);
      margin: 0 auto;
      background: rgba(255,255,255,0.04);
      position: relative;
      user-select:none;
      touch-action: manipulation;
    }

    .sq{
      position:relative;
      display:grid;
      place-items:center;
      font-size: clamp(28px, 4.8vw, 44px);
      line-height: 1;
      cursor:pointer;
      transition: filter .08s ease;
    }

    .light{ background: var(--board-light); }
    .dark{  background: var(--board-dark); }
    .sq:hover{ filter: brightness(1.03); }

    .sq.selected::after{
      content:"";
      position:absolute;
      inset: 0;
      background: var(--hl-selected);
      outline: 2px solid rgba(124,92,255,0.55);
      outline-offset:-2px;
      pointer-events:none;
    }
    .sq.last::after{
      content:"";
      position:absolute;
      inset: 0;
      background: var(--hl-last);
      pointer-events:none;
    }
    .sq.check::after{
      content:"";
      position:absolute;
      inset: 0;
      background: var(--hl-check);
      pointer-events:none;
    }

    .dot{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: var(--dot);
      position:absolute;
      inset: 0;
      margin:auto;
      pointer-events:none;
    }
    .dot.capture{
      width: 52%;
      height: 52%;
      border: 3px solid rgba(0,0,0,0.25);
      background: transparent;
      border-radius: 999px;
    }

    .coords{
      display:flex;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-family: var(--mono);
      font-size: 12px;
      opacity:.9;
      margin: 0 auto;
      width: min(560px, 86vw);
    }

    /* Side panel */
    .side{
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
      position: sticky;
      top: 86px;
    }
    @media (max-width: 980px){
      .side{position: static}
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }

    .stat{
      font-family: var(--mono);
      font-size: 13px;
      color: var(--muted);
    }
    .stat strong{color: var(--text)}

    .select{
      width: 100%;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.07);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 650;
    }

    .status{
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-weight: 700;
    }
    .status small{
      display:block;
      margin-top:4px;
      color: var(--muted);
      font-weight: 600;
    }

    .log{
      max-height: 220px;
      overflow:auto;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      padding: 10px;
    }
    .log ul{margin:0; padding:0; list-style:none}
    .log li{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding: 8px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,0.82);
    }
    .log li:last-child{border-bottom:none}
    .tag{
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(255,255,255,0.85);
      background: rgba(255,255,255,0.06);
      white-space: nowrap;
      align-self:center;
    }
    .tag.w{border-color: rgba(57,200,145,.35)}
    .tag.b{border-color: rgba(255,92,122,.35)}

    /* Menus / Modals */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      padding: 18px;
      background: rgba(0,0,0,0.60);
      backdrop-filter: blur(8px);
      z-index: 3000;
    }
    .modal{
      width: min(680px, 96vw);
      padding: 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(18,23,36,0.92), rgba(10,14,22,0.92));
      box-shadow: var(--shadow);
    }
    .modal h1, .modal h2{margin: 6px 0 10px}
    .modal p{margin: 0 0 12px; color: var(--muted); line-height: 1.45}
    .menu-grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 10px;
    }
    @media (max-width: 560px){
      .menu-grid{grid-template-columns: 1fr}
    }
    .menu-card{
      padding: 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .menu-card h3{
      margin:0;
      display:flex;
      gap:10px;
      align-items:center;
      font-size: 16px;
    }
    .menu-card h3 svg{opacity:.95}
    .menu-card small{color: var(--muted)}
    .menu-actions{display:flex; gap:10px; flex-wrap:wrap}
    .footer{
      margin-top: 10px;
      color: rgba(255,255,255,0.55);
      font-size: 12px;
      text-align:center;
    }

    .settings-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 740px){
      .settings-grid{grid-template-columns: 1fr}
    }
    .field{
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
    }
    .field h4{margin:0 0 10px}
    .radio{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.16);
      cursor:pointer;
      margin-bottom: 8px;
    }
    .radio:hover{background: rgba(0,0,0,0.22)}
    .swatches{display:flex; gap:6px; margin-left:auto}
    .swatch{width:18px; height:18px; border-radius: 6px; border:1px solid rgba(255,255,255,0.10)}
    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .toggle input{transform: scale(1.1)}
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
    }

    /* Themes (board colors only) */
    .theme-default{
      --board-light:#f0d9b5;
      --board-dark:#b58863;
      --hl-last: rgba(57,200,145,0.35);
      --hl-selected: rgba(124,92,255,0.40);
      --hl-check: rgba(255,92,122,0.45);
    }
    .theme-neon{
      --board-light:#141414;
      --board-dark:#000000;
      --hl-last: rgba(0,255,120,0.30);
      --hl-selected: rgba(255,0,255,0.30);
      --hl-check: rgba(255,0,0,0.30);
      --dot: rgba(255,255,255,0.16);
      --dot-capture: rgba(255,255,255,0.22);
    }
    .theme-forest{
      --board-light:#c9dbc5;
      --board-dark:#769656;
      --hl-last: rgba(148,189,143,0.40);
      --hl-selected: rgba(247,226,107,0.45);
      --hl-check: rgba(232,72,85,0.40);
    }
  </style>
</head>

<body class="theme-default">
  <site-navbar cart-href="https://unlim8ted.com/sign-in/cart" signin-href="https://unlim8ted.com/sign-in"
    profile-href="https://unlim8ted.com/profile"></site-navbar>

  <div class="app">
    <div class="hud panel">
      <div class="hud-left">
        <div class="brand">
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 2a10 10 0 1 0 10 10A10.01 10.01 0 0 0 12 2Zm0 18a8 8 0 1 1 8-8a8.01 8.01 0 0 1-8 8Z"/>
            <path d="M12 6a1 1 0 0 0-1 1v4.2l-2.4 2.4a1 1 0 1 0 1.4 1.4l2.7-2.7A1 1 0 0 0 13 12V7a1 1 0 0 0-1-1Z"/>
          </svg>
          <b>Unlim8ted Chess</b>
        </div>
        <span class="pill"><span id="modePill">Mode: <strong>Menu</strong></span></span>
        <span class="pill">Difficulty: <strong id="diffPill">Medium</strong></span>
      </div>

      <div class="hud-right">
        <button class="ghost" id="menuBtn">Menu</button>
        <button class="icon-btn" id="settingsBtn" aria-label="Settings">
          <!-- modern SVG gear -->
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M19.14 12.94a7.49 7.49 0 0 0 .05-.94 7.49 7.49 0 0 0-.05-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.28 7.28 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.42l-.36 2.54c-.58.23-1.12.54-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L1.71 7.48a.5.5 0 0 0 .12.64l2.03 1.58c-.03.31-.05.63-.05.94s.02.63.05.94L1.83 14.52a.5.5 0 0 0-.12.64l1.92 3.32a.5.5 0 0 0 .6.22l2.39-.96c.5.4 1.05.71 1.63.94l.36 2.54a.5.5 0 0 0 .49.42h3.8a.5.5 0 0 0 .49-.42l.36-2.54c.58-.23 1.12-.54 1.63-.94l2.39.96a.5.5 0 0 0 .6-.22l1.92-3.32a.5.5 0 0 0-.12-.64ZM12 15.5A3.5 3.5 0 1 1 15.5 12 3.5 3.5 0 0 1 12 15.5Z"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="grid">
      <div class="board-card panel">
        <div class="board-wrap">
          <div class="board" id="board" aria-label="Chessboard" role="grid"></div>
          <div class="coords">
            <div>Files: a b c d e f g h</div>
            <div id="turnText">Turn: White</div>
          </div>
        </div>
      </div>

      <div class="side panel">
        <div class="row">
          <div class="stat">Time: <strong id="timer">00:00</strong></div>
          <div class="stat">Eval: <strong id="evalText">—</strong></div>
        </div>

        <div class="status" id="status">
          Open the menu to start.
          <small>Tip: enable “Show legal moves” in Settings.</small>
        </div>

        <div class="row">
          <button class="primary" id="newGameBtn">New Game</button>
          <button class="ghost" id="flipBtn" title="Flip board">Flip</button>
        </div>

        <div class="log" aria-label="Move log">
          <ul id="moveLog"></ul>
        </div>

        <div class="footer" id="footer-text">© 2019-2026 Unlim8ted Studio Productions. All rights reserved.</div>
      </div>
    </div>
  </div>

  <!-- MAIN MENU -->
  <div class="overlay" id="menuOverlay" role="dialog" aria-modal="true">
    <div class="modal">
      <h1>Challenge an AI to Chess</h1>
      <p>Modern UI + a real(ish) chess engine: legal moves, check/checkmate, castling, en passant, promotion, and AI that actually changes with difficulty.</p>

      <div class="menu-grid">
        <div class="menu-card">
          <h3>
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a7 7 0 0 0-7 7v3a7 7 0 1 0 14 0V9a7 7 0 0 0-7-7Zm5 10a5 5 0 1 1-10 0V9a5 5 0 0 1 10 0Z"/></svg>
            Play vs AI
          </h3>
          <small>Pick difficulty, play as White by default.</small>
          <div class="menu-actions">
            <button class="primary" data-start="ai" data-diff="easy">Easy</button>
            <button class="primary" data-start="ai" data-diff="medium">Medium</button>
            <button class="primary" data-start="ai" data-diff="hard">Hard</button>
          </div>
        </div>

        <div class="menu-card">
          <h3>
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M16 11a4 4 0 1 0-8 0a4 4 0 0 0 8 0Zm-8 7a6 6 0 0 1 12 0v2H8Z"/></svg>
            Play vs Player
          </h3>
          <small>Local 2-player on one device.</small>
          <div class="menu-actions">
            <button class="primary" data-start="pvp">Start PvP</button>
          </div>
        </div>

        <div class="menu-card">
          <h3>
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M7 2h10v2H7Zm-2 4h14v14H5Zm2 2v10h10V8Z"/></svg>
            AI vs AI
          </h3>
          <small>Watch two AIs play. Uses chosen difficulty for both.</small>
          <div class="menu-actions">
            <button class="primary" data-start="aivai" data-diff="easy">Easy</button>
            <button class="primary" data-start="aivai" data-diff="medium">Medium</button>
            <button class="primary" data-start="aivai" data-diff="hard">Hard</button>
          </div>
        </div>

        <div class="menu-card">
          <h3>
            <svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2a10 10 0 1 0 10 10A10.01 10.01 0 0 0 12 2Zm1 15h-2v-2h2Zm0-4h-2V7h2Z"/></svg>
            Tutorial
          </h3>
          <small>Short guided basics (WIP) — still playable.</small>
          <div class="menu-actions">
            <button class="primary" data-start="tutorial">Start Tutorial</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px; justify-content:space-between">
        <span class="pill">Keyboard: <span class="kbd">Esc</span> closes modals</span>
        <button class="ghost" id="closeMenuBtn">Close</button>
      </div>

      <div class="footer" style="margin-top:10px">
        <span id="footer-text-2"></span>
      </div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div class="overlay" id="settingsOverlay" role="dialog" aria-modal="true">
    <div class="modal">
      <h2>Settings</h2>
      <p>Visual theme + gameplay helpers. Pieces are emojis (fast + consistent); UI icons are SVG.</p>

      <div class="settings-grid">
        <div class="field">
          <h4>Board Theme</h4>

          <label class="radio" data-theme="default">
            <input type="radio" name="theme" value="default" checked />
            <span>Default</span>
            <span class="swatches" aria-hidden="true">
              <span class="swatch" style="background:#f0d9b5"></span>
              <span class="swatch" style="background:#b58863"></span>
              <span class="swatch" style="background:rgba(57,200,145,.35)"></span>
            </span>
          </label>

          <label class="radio" data-theme="neon">
            <input type="radio" name="theme" value="neon" />
            <span>Neon</span>
            <span class="swatches" aria-hidden="true">
              <span class="swatch" style="background:#141414"></span>
              <span class="swatch" style="background:#000000"></span>
              <span class="swatch" style="background:rgba(0,255,120,.30)"></span>
            </span>
          </label>

          <label class="radio" data-theme="forest">
            <input type="radio" name="theme" value="forest" />
            <span>Forest</span>
            <span class="swatches" aria-hidden="true">
              <span class="swatch" style="background:#c9dbc5"></span>
              <span class="swatch" style="background:#769656"></span>
              <span class="swatch" style="background:rgba(247,226,107,.45)"></span>
            </span>
          </label>
        </div>

        <div class="field">
          <h4>Gameplay</h4>
          <label class="toggle">
            <input type="checkbox" id="showMovesToggle" />
            <span>Show legal moves</span>
          </label>

          <label class="toggle" style="margin-top:10px">
            <input type="checkbox" id="autoQueenToggle" checked />
            <span>Auto-queen on promotion</span>
          </label>

          <label class="toggle" style="margin-top:10px">
            <input type="checkbox" id="soundToggle" />
            <span>Sounds (optional)</span>
          </label>

          <div style="margin-top:12px">
            <div class="stat">AI strength is real:</div>
            <div class="stat" style="margin-top:6px">
              <strong>Easy</strong> = shallow search + randomness<br>
              <strong>Medium</strong> = deeper + less random<br>
              <strong>Hard</strong> = deeper alpha-beta, basic evaluation
            </div>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px; justify-content:flex-end">
        <button class="ghost" id="closeSettingsBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Promotion (only if auto-queen disabled) -->
  <div class="overlay" id="promoOverlay" role="dialog" aria-modal="true">
    <div class="modal" style="width:min(520px,96vw)">
      <h2>Promote pawn</h2>
      <p>Choose a piece:</p>
      <div class="row" style="justify-content:center; gap:12px; margin-top:10px">
        <button class="primary" data-promote="q">Queen ♕</button>
        <button class="primary" data-promote="r">Rook ♖</button>
        <button class="primary" data-promote="b">Bishop ♗</button>
        <button class="primary" data-promote="n">Knight ♘</button>
      </div>
      <div class="row" style="margin-top:12px; justify-content:flex-end">
        <button class="ghost" id="cancelPromoBtn">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    /******************************************************************
     * Modern single-file chess with:
     * - Legal move gen (incl castling/en passant/promotion)
     * - Check/checkmate/stalemate detection
     * - AI with real difficulty via alpha-beta depth + randomness
     * - SVG UI icons (pieces are emoji per your note)
     ******************************************************************/

    // Footer year
    (function () {
      const y = new Date().getFullYear();
      const text = `© 2019-${y} Unlim8ted Studio Productions. All rights reserved.`;
      document.getElementById("footer-text").textContent = text;
      document.getElementById("footer-text-2").textContent = text;
    })();

    // UI refs
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const timerEl = document.getElementById('timer');
    const evalEl = document.getElementById('evalText');
    const moveLogEl = document.getElementById('moveLog');
    const turnTextEl = document.getElementById('turnText');
    const diffPillEl = document.getElementById('diffPill');
    const modePillEl = document.getElementById('modePill');

    const menuOverlay = document.getElementById('menuOverlay');
    const settingsOverlay = document.getElementById('settingsOverlay');
    const promoOverlay = document.getElementById('promoOverlay');

    const menuBtn = document.getElementById('menuBtn');
    const closeMenuBtn = document.getElementById('closeMenuBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');

    const newGameBtn = document.getElementById('newGameBtn');
    const flipBtn = document.getElementById('flipBtn');

    const showMovesToggle = document.getElementById('showMovesToggle');
    const autoQueenToggle = document.getElementById('autoQueenToggle');
    const soundToggle = document.getElementById('soundToggle');
    const cancelPromoBtn = document.getElementById('cancelPromoBtn');

    // Settings
    let showMoves = false;
    let autoQueen = true;
    let soundOn = false;
    let flipped = false;

    showMovesToggle.addEventListener('change', e => { showMoves = e.target.checked; render(); });
    autoQueenToggle.addEventListener('change', e => { autoQueen = e.target.checked; });
    soundToggle.addEventListener('change', e => { soundOn = e.target.checked; });

    // Theme selection
    document.querySelectorAll('.radio[data-theme]').forEach(lbl => {
      lbl.addEventListener('click', () => {
        const t = lbl.dataset.theme;
        document.body.classList.remove('theme-default','theme-neon','theme-forest');
        document.body.classList.add(`theme-${t}`);
        lbl.querySelector('input').checked = true;
        render();
      });
    });

    // Modal open/close helpers
    function openOverlay(el){ el.style.display = 'grid'; }
    function closeOverlay(el){ el.style.display = 'none'; }

    menuBtn.addEventListener('click', () => openOverlay(menuOverlay));
    closeMenuBtn.addEventListener('click', () => closeOverlay(menuOverlay));
    settingsBtn.addEventListener('click', () => openOverlay(settingsOverlay));
    closeSettingsBtn.addEventListener('click', () => closeOverlay(settingsOverlay));

    menuOverlay.addEventListener('click', e => { if(e.target === menuOverlay) closeOverlay(menuOverlay); });
    settingsOverlay.addEventListener('click', e => { if(e.target === settingsOverlay) closeOverlay(settingsOverlay); });
    promoOverlay.addEventListener('click', e => { if(e.target === promoOverlay) {/* block outside close */} });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeOverlay(menuOverlay);
        closeOverlay(settingsOverlay);
        // promotion overlay stays until action/cancel
      }
    });

    // Game modes
    let mode = 'menu'; // menu | ai | pvp | aivai | tutorial
    let difficulty = 'medium'; // easy | medium | hard
    let gameRunning = false;

    // Timer
    let startTime = null;
    let timerInt = null;
    function timerStart(){
      startTime = Date.now();
      clearInterval(timerInt);
      timerInt = setInterval(() => {
        const s = Math.floor((Date.now() - startTime)/1000);
        const mm = String(Math.floor(s/60)).padStart(2,'0');
        const ss = String(s%60).padStart(2,'0');
        timerEl.textContent = `${mm}:${ss}`;
      }, 250);
    }
    function timerStop(){
      clearInterval(timerInt);
      timerInt = null;
    }

    // Piece emojis (fast + consistent)
    const PIECE_EMOJI = {
      'P':'♙','N':'♘','B':'♗','R':'♖','Q':'♕','K':'♔',
      'p':'♟','n':'♞','b':'♝','r':'♜','q':'♛','k':'♚'
    };

    /***********************
     * Board representation
     * 0..63 (a1=0, h8=63)
     ***********************/
    const FILES = 'abcdefgh';
    function idx(file, rank){ return rank*8 + file; } // file 0..7, rank 0..7 where rank0 = 1
    function fileOf(i){ return i % 8; }
    function rankOf(i){ return (i/8)|0; }
    function inBoard(i){ return i>=0 && i<64; }
    function sqName(i){ return FILES[fileOf(i)] + (rankOf(i)+1); }
    function fromName(s){
      const f = FILES.indexOf(s[0]);
      const r = parseInt(s[1],10)-1;
      return idx(f,r);
    }

    // Initial position (rank 8 at top in UI, but our internal rank0=a1 is bottom)
    const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

    // Game state
    let board = new Array(64).fill('');
    let sideToMove = 'w'; // 'w' | 'b'
    let castling = { K:true, Q:true, k:true, q:true };
    let epSquare = -1; // index or -1
    let halfmoveClock = 0;
    let fullmoveNumber = 1;

    let selected = -1;
    let legalMovesCache = []; // moves for sideToMove
    let lastMove = null;
    let pendingPromotion = null; // {from,to,color}

    // AI vs AI interval
    let aiInterval = null;

    // Sounds (optional, very light)
    const SFX = {
      move: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA="),
      capture: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA="),
    };
    function playSfx(name){
      if(!soundOn) return;
      try { SFX[name].currentTime = 0; SFX[name].play(); } catch {}
    }

    /***********************
     * FEN load/save
     ***********************/
    function loadFEN(fen){
      const parts = fen.split(/\s+/);
      const rows = parts[0].split('/');
      board.fill('');
      let r = 7;
      for(const row of rows){
        let f = 0;
        for(const ch of row){
          if(/[1-8]/.test(ch)){
            f += parseInt(ch,10);
          } else {
            board[idx(f,r)] = ch;
            f++;
          }
        }
        r--;
      }
      sideToMove = parts[1];
      castling = { K:false,Q:false,k:false,q:false };
      if(parts[2] !== '-'){
        for(const c of parts[2]) castling[c] = true;
      }
      epSquare = (parts[3] === '-') ? -1 : fromName(parts[3]);
      halfmoveClock = parseInt(parts[4]||"0",10);
      fullmoveNumber = parseInt(parts[5]||"1",10);

      selected = -1;
      lastMove = null;
      pendingPromotion = null;
      legalMovesCache = generateLegalMoves(sideToMove);
    }

    /***********************
     * Move structure:
     * { from, to, piece, capture, promo, ep, castle }
     ***********************/
    function isWhitePiece(p){ return p && p === p.toUpperCase(); }
    function isBlackPiece(p){ return p && p === p.toLowerCase(); }
    function colorOf(p){ return isWhitePiece(p) ? 'w' : 'b'; }
    function enemyColor(c){ return c === 'w' ? 'b' : 'w'; }

    function kingIndex(color){
      const k = (color==='w') ? 'K' : 'k';
      for(let i=0;i<64;i++) if(board[i]===k) return i;
      return -1;
    }

    // Directions
    const DIRS = {
      N: 8, S: -8, E: 1, W: -1,
      NE: 9, NW: 7, SE: -7, SW: -9
    };

    function sameRow(a,b){ return rankOf(a) === rankOf(b); }
    function sameFile(a,b){ return fileOf(a) === fileOf(b); }

    function attackedBy(color, sq){
      // returns true if sq is attacked by color
      // pawns
      if(color==='w'){
        const a = sq - 7, b = sq - 9;
        if(inBoard(a) && board[a]==='P' && fileOf(a)!==0) return true;
        if(inBoard(b) && board[b]==='P' && fileOf(b)!==7) return true;
      } else {
        const a = sq + 7, b = sq + 9;
        if(inBoard(a) && board[a]==='p' && fileOf(a)!==7) return true;
        if(inBoard(b) && board[b]==='p' && fileOf(b)!==0) return true;
      }
      // knights
      const KN = [17,15,10,6,-6,-10,-15,-17];
      for(const d of KN){
        const t = sq + d;
        if(!inBoard(t)) continue;
        // filter wrap: ensure knight move doesn't wrap across board
        const df = Math.abs(fileOf(t)-fileOf(sq));
        const dr = Math.abs(rankOf(t)-rankOf(sq));
        if(!((df===1&&dr===2)||(df===2&&dr===1))) continue;
        const p = board[t];
        if(!p) continue;
        if(color==='w' && p==='N') return true;
        if(color==='b' && p==='n') return true;
      }
      // sliders: bishops/queens (diagonals)
      const diag = [DIRS.NE,DIRS.NW,DIRS.SE,DIRS.SW];
      for(const d of diag){
        let t = sq + d;
        while(inBoard(t) && Math.abs(fileOf(t)-fileOf(t-d))===1){
          const p = board[t];
          if(p){
            if(color==='w' && (p==='B'||p==='Q')) return true;
            if(color==='b' && (p==='b'||p==='q')) return true;
            break;
          }
          t += d;
        }
      }
      // sliders: rooks/queens (orth)
      const ort = [DIRS.N,DIRS.S,DIRS.E,DIRS.W];
      for(const d of ort){
        let t = sq + d;
        while(inBoard(t) && (d===DIRS.E||d===DIRS.W ? sameRow(t,t-d) : true)){
          const p = board[t];
          if(p){
            if(color==='w' && (p==='R'||p==='Q')) return true;
            if(color==='b' && (p==='r'||p==='q')) return true;
            break;
          }
          t += d;
        }
      }
      // king
      const KG = [DIRS.N,DIRS.S,DIRS.E,DIRS.W,DIRS.NE,DIRS.NW,DIRS.SE,DIRS.SW];
      for(const d of KG){
        const t = sq + d;
        if(!inBoard(t)) continue;
        if(Math.abs(fileOf(t)-fileOf(sq))>1) continue;
        const p = board[t];
        if(color==='w' && p==='K') return true;
        if(color==='b' && p==='k') return true;
      }
      return false;
    }

    function inCheck(color){
      const k = kingIndex(color);
      if(k<0) return false;
      return attackedBy(enemyColor(color), k);
    }

    function generatePseudoMoves(color){
      const moves = [];
      for(let i=0;i<64;i++){
        const p = board[i];
        if(!p) continue;
        if(color==='w' && !isWhitePiece(p)) continue;
        if(color==='b' && !isBlackPiece(p)) continue;

        const pc = p.toLowerCase();
        const f = fileOf(i), r = rankOf(i);

        if(pc==='p'){
          const dir = (color==='w') ? 8 : -8;
          const startRank = (color==='w') ? 1 : 6;
          const promoRank = (color==='w') ? 7 : 0;

          const one = i + dir;
          if(inBoard(one) && !board[one]){
            // promotion
            if(rankOf(one) === promoRank){
              for(const pr of ['q','r','b','n']){
                moves.push({from:i,to:one,piece:p,capture:'',promo: color==='w'?pr.toUpperCase():pr, ep:false, castle:false});
              }
            } else {
              moves.push({from:i,to:one,piece:p,capture:'',promo:'', ep:false, castle:false});
              // two
              if(r === startRank){
                const two = i + dir*2;
                if(inBoard(two) && !board[two]){
                  moves.push({from:i,to:two,piece:p,capture:'',promo:'', ep:false, castle:false});
                }
              }
            }
          }

          // captures
          const capDirs = (color==='w') ? [7,9] : [-7,-9];
          for(const cd of capDirs){
            const t = i + cd;
            if(!inBoard(t)) continue;

            // prevent wrap on diagonal captures
            const df = Math.abs(fileOf(t) - f);
            if(df !== 1) continue;

            const tp = board[t];

            // normal capture
            if(tp && colorOf(tp) !== color){
              if(rankOf(t) === promoRank){
                for(const pr of ['q','r','b','n']){
                  moves.push({from:i,to:t,piece:p,capture:tp,promo: color==='w'?pr.toUpperCase():pr, ep:false, castle:false});
                }
              } else {
                moves.push({from:i,to:t,piece:p,capture:tp,promo:'', ep:false, castle:false});
              }
            }

            // en passant
            if(t === epSquare){
              // ep capture target is behind epSquare
              moves.push({from:i,to:t,piece:p,capture: (color==='w' ? 'p' : 'P'), promo:'', ep:true, castle:false});
            }
          }
        }
        else if(pc==='n'){
          const KN = [17,15,10,6,-6,-10,-15,-17];
          for(const d of KN){
            const t = i + d;
            if(!inBoard(t)) continue;
            const df = Math.abs(fileOf(t)-f);
            const dr = Math.abs(rankOf(t)-r);
            if(!((df===1&&dr===2)||(df===2&&dr===1))) continue;
            const tp = board[t];
            if(!tp || colorOf(tp) !== color){
              moves.push({from:i,to:t,piece:p,capture: tp||'', promo:'', ep:false, castle:false});
            }
          }
        }
        else if(pc==='b' || pc==='r' || pc==='q'){
          const dirs = [];
          if(pc==='b' || pc==='q') dirs.push(DIRS.NE,DIRS.NW,DIRS.SE,DIRS.SW);
          if(pc==='r' || pc==='q') dirs.push(DIRS.N,DIRS.S,DIRS.E,DIRS.W);

          for(const d of dirs){
            let t = i + d;
            while(inBoard(t)){
              // prevent wrap on E/W and diagonals
              if((d===DIRS.E||d===DIRS.W) && !sameRow(t, t-d)) break;
              if((d===DIRS.NE||d===DIRS.NW||d===DIRS.SE||d===DIRS.SW) && Math.abs(fileOf(t)-fileOf(t-d))!==1) break;

              const tp = board[t];
              if(!tp){
                moves.push({from:i,to:t,piece:p,capture:'', promo:'', ep:false, castle:false});
              } else {
                if(colorOf(tp) !== color){
                  moves.push({from:i,to:t,piece:p,capture:tp, promo:'', ep:false, castle:false});
                }
                break;
              }
              t += d;
            }
          }
        }
        else if(pc==='k'){
          const KG = [DIRS.N,DIRS.S,DIRS.E,DIRS.W,DIRS.NE,DIRS.NW,DIRS.SE,DIRS.SW];
          for(const d of KG){
            const t = i + d;
            if(!inBoard(t)) continue;
            if(Math.abs(fileOf(t)-f)>1) continue;
            const tp = board[t];
            if(!tp || colorOf(tp) !== color){
              moves.push({from:i,to:t,piece:p,capture:tp||'', promo:'', ep:false, castle:false});
            }
          }

          // castling (pseudo, checked later for legality)
          if(color==='w'){
            // King on e1 (4), rooks on a1/h1
            if(i === fromName('e1') && !inCheck('w')){
              if(castling.K && board[fromName('f1')]==='' && board[fromName('g1')]===''){
                // squares f1,g1 must not be attacked
                if(!attackedBy('b', fromName('f1')) && !attackedBy('b', fromName('g1'))){
                  moves.push({from:i,to:fromName('g1'),piece:p,capture:'',promo:'',ep:false,castle:'K'});
                }
              }
              if(castling.Q && board[fromName('d1')]==='' && board[fromName('c1')]==='' && board[fromName('b1')]===''){
                if(!attackedBy('b', fromName('d1')) && !attackedBy('b', fromName('c1'))){
                  moves.push({from:i,to:fromName('c1'),piece:p,capture:'',promo:'',ep:false,castle:'Q'});
                }
              }
            }
          } else {
            if(i === fromName('e8') && !inCheck('b')){
              if(castling.k && board[fromName('f8')]==='' && board[fromName('g8')]===''){
                if(!attackedBy('w', fromName('f8')) && !attackedBy('w', fromName('g8'))){
                  moves.push({from:i,to:fromName('g8'),piece:p,capture:'',promo:'',ep:false,castle:'k'});
                }
              }
              if(castling.q && board[fromName('d8')]==='' && board[fromName('c8')]==='' && board[fromName('b8')]===''){
                if(!attackedBy('w', fromName('d8')) && !attackedBy('w', fromName('c8'))){
                  moves.push({from:i,to:fromName('c8'),piece:p,capture:'',promo:'',ep:false,castle:'q'});
                }
              }
            }
          }
        }
      }
      return moves;
    }

    function makeMove(m){
      // returns undo object
      const undo = {
        from: m.from, to: m.to,
        moved: board[m.from],
        captured: board[m.to],
        castling: {...castling},
        epSquare,
        halfmoveClock,
        fullmoveNumber,
        sideToMove,
        lastMove
      };

      const piece = board[m.from];
      const color = colorOf(piece);

      // halfmove clock
      if(m.capture || piece.toLowerCase()==='p') halfmoveClock = 0;
      else halfmoveClock++;

      // clear ep by default
      epSquare = -1;

      // move the piece
      board[m.from] = '';

      // en passant capture removes pawn behind target
      if(m.ep){
        const capIdx = m.to + (color==='w' ? -8 : 8);
        undo.epCapturedIndex = capIdx;
        undo.epCapturedPiece = board[capIdx];
        board[capIdx] = '';
      }

      // castling rook move
      if(m.castle){
        if(m.castle==='K'){ // white king side
          board[fromName('h1')] = '';
          board[fromName('f1')] = 'R';
        } else if(m.castle==='Q'){
          board[fromName('a1')] = '';
          board[fromName('d1')] = 'R';
        } else if(m.castle==='k'){ // black king side
          board[fromName('h8')] = '';
          board[fromName('f8')] = 'r';
        } else if(m.castle==='q'){
          board[fromName('a8')] = '';
          board[fromName('d8')] = 'r';
        }
      }

      // promotion
      if(m.promo){
        board[m.to] = m.promo;
      } else {
        board[m.to] = piece;
      }

      // set ep square if double pawn push
      if(piece.toLowerCase()==='p'){
        const delta = m.to - m.from;
        if(delta === 16 || delta === -16){
          epSquare = m.from + (delta/2);
        }
      }

      // update castling rights if king/rook moved or rook captured
      if(piece === 'K'){ castling.K=false; castling.Q=false; }
      if(piece === 'k'){ castling.k=false; castling.q=false; }
      if(piece === 'R'){
        if(m.from === fromName('h1')) castling.K=false;
        if(m.from === fromName('a1')) castling.Q=false;
      }
      if(piece === 'r'){
        if(m.from === fromName('h8')) castling.k=false;
        if(m.from === fromName('a8')) castling.q=false;
      }
      // rook captured affects rights too
      if(m.capture){
        if(m.to === fromName('h1')) castling.K=false;
        if(m.to === fromName('a1')) castling.Q=false;
        if(m.to === fromName('h8')) castling.k=false;
        if(m.to === fromName('a8')) castling.q=false;
      }

      // swap side
      sideToMove = enemyColor(sideToMove);

      // fullmove increment after black moves
      if(sideToMove === 'w') fullmoveNumber++;

      lastMove = {from:m.from,to:m.to};
      return undo;
    }

    function undoMove(undo){
      board[undo.from] = undo.moved;
      board[undo.to] = undo.captured;

      // restore en passant capture
      if(undo.epCapturedIndex != null){
        board[undo.epCapturedIndex] = undo.epCapturedPiece;
      }

      // restore castling rook move if it was a castle
      // Detect by undo.lastMove vs current lastMove doesn't help; instead reconstruct using positions:
      // We can revert rook if king ended on g/c squares and king is on from square after restore
      // But easier: check moved piece was king and distance was 2 squares
      if(undo.moved.toLowerCase() === 'k' && Math.abs(undo.to - undo.from) === 2){
        if(undo.moved === 'K'){
          if(undo.to === fromName('g1')){
            board[fromName('h1')] = 'R'; board[fromName('f1')] = '';
          } else if(undo.to === fromName('c1')){
            board[fromName('a1')] = 'R'; board[fromName('d1')] = '';
          }
        } else {
          if(undo.to === fromName('g8')){
            board[fromName('h8')] = 'r'; board[fromName('f8')] = '';
          } else if(undo.to === fromName('c8')){
            board[fromName('a8')] = 'r'; board[fromName('d8')] = '';
          }
        }
      }

      castling = {...undo.castling};
      epSquare = undo.epSquare;
      halfmoveClock = undo.halfmoveClock;
      fullmoveNumber = undo.fullmoveNumber;
      sideToMove = undo.sideToMove;
      lastMove = undo.lastMove;
    }

    function generateLegalMoves(color){
      const pse = generatePseudoMoves(color);
      const leg = [];
      for(const m of pse){
        const u = makeMove(m);
        const ok = !inCheck(color);
        undoMove(u);
        if(ok) leg.push(m);
      }
      return leg;
    }

    function moveToSAN(m){
      // lightweight SAN-ish (not fully disambiguated, but clean for logs)
      const p = m.piece.toLowerCase();
      const isPawn = p==='p';
      const isKing = p==='k';
      const to = sqName(m.to);

      if(m.castle){
        if(m.castle==='K'||m.castle==='k') return 'O-O';
        return 'O-O-O';
      }

      let s = '';
      if(!isPawn){
        const map = {n:'N',b:'B',r:'R',q:'Q',k:'K'};
        s += map[p];
      } else {
        // pawn captures show file
        if(m.capture || m.ep){
          s += FILES[fileOf(m.from)];
        }
      }

      if(m.capture || m.ep) s += 'x';
      s += to;

      if(m.promo){
        s += '=' + m.promo.toUpperCase();
      }

      // check / mate marker
      const u = makeMove(m);
      const opp = sideToMove; // after move, sideToMove already swapped
      const oppInCheck = inCheck(opp);
      const oppMoves = generateLegalMoves(opp);
      undoMove(u);

      if(oppInCheck && oppMoves.length === 0) s += '#';
      else if(oppInCheck) s += '+';

      return s;
    }

    /***********************
     * Evaluation + AI
     ***********************/
    const VAL = { p:100, n:320, b:330, r:500, q:900, k:20000 };

    function evaluate(colorPerspective){
      // positive = good for colorPerspective
      let score = 0;
      for(let i=0;i<64;i++){
        const p = board[i];
        if(!p) continue;
        const v = VAL[p.toLowerCase()] || 0;
        score += isWhitePiece(p) ? v : -v;
      }
      // Convert to perspective
      if(colorPerspective==='b') score = -score;
      return score;
    }

    function randInt(n){ return (Math.random()*n)|0; }

    function pickAIMove(color, diff){
      const legal = generateLegalMoves(color);
      if(legal.length === 0) return null;

      const cfg = {
        easy:   { depth: 2, jitter: 60, topK: 6 },
        medium: { depth: 3, jitter: 18, topK: 4 },
        hard:   { depth: 4, jitter: 6,  topK: 2 }
      }[diff] || { depth: 3, jitter: 18, topK: 4 };

      // alpha-beta
      function alphabeta(depth, alpha, beta, turnColor){
        const legalMoves = generateLegalMoves(turnColor);

        if(depth === 0 || legalMoves.length === 0){
          // terminal
          if(legalMoves.length === 0){
            if(inCheck(turnColor)){
              // mate for side to move
              const mateScore = -100000 + (cfg.depth - depth) * 50;
              return mateScore;
            } else {
              return 0; // stalemate
            }
          }
          return evaluate(color) * (turnColor===color ? 1 : 1); // evaluation from AI color perspective
        }

        const maximizing = (turnColor === color);
        let best = maximizing ? -1e9 : 1e9;

        // simple move ordering: captures first
        legalMoves.sort((a,b) => (b.capture?1:0) - (a.capture?1:0));

        for(const m of legalMoves){
          const u = makeMove(m);
          const val = alphabeta(depth-1, alpha, beta, sideToMove);
          undoMove(u);

          if(maximizing){
            if(val > best) best = val;
            if(best > alpha) alpha = best;
            if(alpha >= beta) break;
          } else {
            if(val < best) best = val;
            if(best < beta) beta = best;
            if(alpha >= beta) break;
          }
        }
        return best;
      }

      // score root moves
      const scored = [];
      for(const m of legal){
        const u = makeMove(m);
        const v = alphabeta(cfg.depth-1, -1e9, 1e9, sideToMove);
        undoMove(u);

        // add controlled randomness
        const noisy = v + (randInt(cfg.jitter*2+1) - cfg.jitter);
        scored.push({m, v, noisy});
      }

      scored.sort((a,b) => b.noisy - a.noisy);

      const pickFrom = Math.min(cfg.topK, scored.length);
      const choice = scored[randInt(pickFrom)].m;

      // eval text (approx)
      const bestV = scored[0].v;
      evalEl.textContent = (bestV>=0?'+':'') + (bestV/100).toFixed(2);

      return choice;
    }

    /***********************
     * UI: render board + clicks
     ***********************/
    function clearHighlights(){
      document.querySelectorAll('.sq').forEach(sq=>{
        sq.classList.remove('selected','last','check');
        sq.innerHTML = ''; // will be repopulated in render
      });
    }

    function render(){
      // rebuild board DOM once (if empty), else update cells
      if(boardEl.childElementCount !== 64){
        boardEl.innerHTML = '';
        for(let uiRank=7; uiRank>=0; uiRank--){
          for(let uiFile=0; uiFile<8; uiFile++){
            const f = flipped ? (7-uiFile) : uiFile;
            const r = flipped ? (7-uiRank) : uiRank;
            const i = idx(f, r);

            const sq = document.createElement('div');
            sq.className = 'sq ' + (((uiFile+uiRank)%2===0) ? 'light' : 'dark');
            sq.dataset.i = String(i);
            sq.setAttribute('role','gridcell');
            sq.addEventListener('click', onSquareClick);
            boardEl.appendChild(sq);
          }
        }
      }

      // update pieces + highlights
      const squares = boardEl.querySelectorAll('.sq');
      squares.forEach(el=>{
        const i = parseInt(el.dataset.i,10);
        const p = board[i];
        el.textContent = p ? PIECE_EMOJI[p] : '';
el.classList.toggle('black-piece', !!p && p === p.toLowerCase());

        el.classList.toggle('selected', i === selected);

        // last move highlight
        if(lastMove && (i===lastMove.from || i===lastMove.to)) el.classList.add('last');
        else el.classList.remove('last');

        el.classList.remove('check');
      });

      // check highlight on king square
      if(inCheck(sideToMove)){
        const k = kingIndex(sideToMove);
        squares.forEach(el=>{
          const i = parseInt(el.dataset.i,10);
          if(i===k) el.classList.add('check');
        });
      }

      // move dots
      // remove any existing dots
      squares.forEach(el=>{
        const d = el.querySelector('.dot');
        if(d) d.remove();
      });

      if(showMoves && selected >= 0){
        const legal = legalMovesCache.filter(m => m.from === selected);
        for(const m of legal){
          const targetEl = Array.from(squares).find(el => parseInt(el.dataset.i,10) === m.to);
          if(!targetEl) continue;
          const dot = document.createElement('div');
          dot.className = 'dot' + ((m.capture || m.ep) ? ' capture' : '');
          targetEl.appendChild(dot);
        }
      }

      // HUD updates
      turnTextEl.textContent = 'Turn: ' + (sideToMove==='w' ? 'White' : 'Black');
      diffPillEl.textContent = difficulty[0].toUpperCase() + difficulty.slice(1);
      const modeNice = {menu:'Menu', ai:'Vs AI', pvp:'PvP', aivai:'AI vs AI', tutorial:'Tutorial'}[mode] || mode;
      modePillEl.innerHTML = `Mode: <strong>${modeNice}</strong>`;

      // ensure cache stays valid if selection changed
      if(gameRunning){
        legalMovesCache = generateLegalMoves(sideToMove);
      }
    }

    function setStatus(line, sub=''){
      statusEl.innerHTML = `${line}${sub ? `<small>${sub}</small>`:''}`;
    }

    function resetLog(){
      moveLogEl.innerHTML = '';
    }

    function addLog(m){
      const li = document.createElement('li');
      const san = moveToSAN(m);
      const sideTag = (colorOf(m.piece)==='w') ? '<span class="tag w">W</span>' : '<span class="tag b">B</span>';
      li.innerHTML = `<span>${san}</span>${sideTag}`;
      moveLogEl.prepend(li);
    }

    function endIfGameOver(){
      const legal = generateLegalMoves(sideToMove);
      if(legal.length === 0){
        if(inCheck(sideToMove)){
          const winner = (sideToMove==='w') ? 'Black' : 'White';
          setStatus(`Checkmate — ${winner} wins.`, 'Open Menu to start another mode, or New Game.');
        } else {
          setStatus('Stalemate — draw.', 'Open Menu to start another mode, or New Game.');
        }
        gameRunning = false;
        timerStop();
        stopAIVsAI();
        return true;
      }
      return false;
    }

    function onSquareClick(e){
      if(!gameRunning) return;
      if(pendingPromotion) return; // block while choosing promotion

      const i = parseInt(e.currentTarget.dataset.i,10);
      const p = board[i];

      // if it's AI's turn and mode is vs AI, ignore clicks
      if(mode === 'ai' && sideToMove === 'b'){ // human plays white by default
        return;
      }
      if(mode === 'aivai') return;

      // select piece
      if(selected < 0){
        if(p && colorOf(p) === sideToMove){
          selected = i;
          render();
        }
        return;
      }

      // clicking same square deselects
      if(i === selected){
        selected = -1;
        render();
        return;
      }

      // if click another own piece, switch selection
      if(p && colorOf(p) === sideToMove){
        selected = i;
        render();
        return;
      }

      // attempt move
      const cand = legalMovesCache.filter(m => m.from === selected && m.to === i);

      if(cand.length === 0){
        // invalid destination -> deselect
        selected = -1;
        render();
        return;
      }

      // if promotion and autoQueen off -> open promo overlay
      const m = cand[0];
      if(m.promo && !autoQueen){
        pendingPromotion = { baseMove: {...m} };
        openOverlay(promoOverlay);
        setStatus('Promotion needed.', 'Choose a piece to promote to.');
        return;
      }

      // auto-queen: convert to queen if promo exists
      if(m.promo && autoQueen){
        // choose queen variant
        const qPromo = (colorOf(m.piece)==='w') ? 'Q' : 'q';
        const qm = {...m, promo:qPromo};
        doMove(qm);
      } else {
        doMove(m);
      }
    }

    function doMove(m){
      const beforeColor = colorOf(m.piece);
      const capture = !!m.capture || !!m.ep;

      makeMove(m);
      addLog(m);
      playSfx(capture ? 'capture' : 'move');

      selected = -1;
      legalMovesCache = generateLegalMoves(sideToMove);

      // status / check text
      if(inCheck(sideToMove)){
        setStatus('Check!', `${sideToMove==='w'?'White':'Black'} is in check.`);
      } else {
        setStatus('In progress.', `${sideToMove==='w'?'White':'Black'} to move.`);
      }

      render();

      if(endIfGameOver()) return;

      // if vs AI and now it's black to move -> AI response
      if(mode === 'ai' && sideToMove === 'b'){
        window.setTimeout(() => aiStep(), 140);
      }
    }

    // Promotion buttons
    document.querySelectorAll('[data-promote]').forEach(btn=>{
      btn.addEventListener('click', () => {
        if(!pendingPromotion) return;
        const pr = btn.dataset.promote;
        const base = pendingPromotion.baseMove;
        const promoPiece = (colorOf(base.piece)==='w') ? pr.toUpperCase() : pr;
        const m = {...base, promo: promoPiece};
        pendingPromotion = null;
        closeOverlay(promoOverlay);
        doMove(m);
      });
    });

    cancelPromoBtn.addEventListener('click', ()=>{
      pendingPromotion = null;
      closeOverlay(promoOverlay);
      setStatus('Promotion cancelled.', 'Pick a different move.');
      render();
    });

    /***********************
     * Modes + Menu actions
     ***********************/
    function stopAIVsAI(){
      if(aiInterval){
        clearInterval(aiInterval);
        aiInterval = null;
      }
    }

    function startNew(modeIn, diffIn){
      mode = modeIn;
      if(diffIn) difficulty = diffIn;

      stopAIVsAI();
      loadFEN(START_FEN);
      resetLog();

      gameRunning = true;
      timerStart();

      // default status
      setStatus('In progress.', 'White to move.');
      closeOverlay(menuOverlay);
      render();

      if(mode === 'ai'){
        // human white, AI black
        if(sideToMove === 'b') setTimeout(aiStep, 120);
      } else if(mode === 'aivai'){
        setStatus('AI vs AI running.', 'Use Menu or New Game to stop.');
        aiInterval = setInterval(aiStep, 180);
      } else if(mode === 'tutorial'){
        setStatus('Tutorial (WIP).', 'Play normally for now — tutorial steps coming soon.');
      } else if(mode === 'pvp'){
        setStatus('Local PvP.', 'White to move.');
      }
    }

    // menu buttons
    document.querySelectorAll('button[data-start]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const m = btn.dataset.start;
        const d = btn.dataset.diff || 'medium';
        startNew(m, d);
      });
    });

    newGameBtn.addEventListener('click', ()=>{
      if(mode === 'menu'){
        openOverlay(menuOverlay);
        return;
      }
      startNew(mode, difficulty);
    });

    flipBtn.addEventListener('click', ()=>{
      flipped = !flipped;
      boardEl.innerHTML = ''; // force rebuild indices
      render();
    });

    function aiStep(){
      if(!gameRunning) return;
      if(pendingPromotion) return;

      // determine if AI should move
      if(mode === 'ai'){
        if(sideToMove !== 'b') return;
      }
      if(mode === 'aivai'){
        // both sides are AI
      }

      const mv = pickAIMove(sideToMove, difficulty);
      if(!mv){
        endIfGameOver();
        return;
      }

      // If AI move is promotion and autoQueen off, just auto-queen anyway for AI
      if(mv.promo && !autoQueen){
        const qPromo = (colorOf(mv.piece)==='w') ? 'Q' : 'q';
        doMove({...mv, promo:qPromo});
      } else {
        doMove(mv);
      }
    }

    /***********************
     * Init
     ***********************/
    function boot(){
      loadFEN(START_FEN);
      openOverlay(menuOverlay);
      setStatus('Open the menu to start.', 'Tip: enable “Show legal moves” in Settings.');
      evalEl.textContent = '—';
      timerEl.textContent = '00:00';
      render();
    }

    boot();
  </script>
</body>
</html>
