<html>

<head>
  <title>Unlim8ted Chess</title>
  <meta property="og:title" content="Unlim8ted Chess">
  <meta name="description"
    content="Play chess against different difficulties of AI. Watch AI play against itself. Learn to play chess. Customizable Visuals. Unlim8ted Chess, always free no sign up required. Powered by Unlim8ted Studio Productions." />
  <!--______________________________START OF LOADING AND NOSCRIPT____________________________________-->
  <link rel="icon" href="https://unlim8ted.com/favicon.ico" type="image/x-icon">

  <style media="screen" type="text/css">
    .loader {
      position: fixed;
      background-color: black;
      opacity: 1;
      height: 100%;
      width: 100%;
      top: 0;
      left: 0%;
      z-index: 999999988;
      pointer-events: none;
    }

    .loaderr-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      /* To stack spinner and text vertically */
      height: 100vh;
      /* Full viewport height to ensure vertical centering */
    }

    .loaderr {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: 8px solid transparent;
      border-top: 8px solid #3498db;
      border-right: 8px solid #e74c3c;
      border-bottom: 8px solid #f1c40f;
      border-left: 8px solid #9b59b6;
      -webkit-animation: spin 1.5s linear infinite;
      animation: spin 1.5s linear infinite;
      box-shadow: 0 0 15px rgba(52, 152, 219, 0.7), 0 0 15px rgba(231, 76, 60, 0.7), 0 0 15px rgba(241, 196, 15, 0.7), 0 0 15px rgba(155, 89, 182, 0.7);
      position: relative;
    }

    .loaderr:before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 8px solid transparent;
      border-top: 8px solid rgba(52, 152, 219, 0.7);
      border-right: 8px solid rgba(231, 76, 60, 0.7);
      border-bottom: 8px solid rgba(241, 196, 15, 0.7);
      border-left: 8px solid rgba(155, 89, 182, 0.7);
      -webkit-animation: spin-reverse 1.5s linear infinite;
      animation: spin-reverse 1.5s linear infinite;
    }

    @-webkit-keyframes spin {
      0% {
        -webkit-transform: rotate(0deg);
      }

      100% {
        -webkit-transform: rotate(360deg);
      }
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    @-webkit-keyframes spin-reverse {
      0% {
        -webkit-transform: rotate(360deg);
      }

      100% {
        -webkit-transform: rotate(0deg);
      }
    }

    @keyframes spin-reverse {
      0% {
        transform: rotate(360deg);
      }

      100% {
        transform: rotate(0deg);
      }
    }

    /* Loading text animation */
    .loading-text {
      margin-top: 20px;
      font-size: 18px;
      color: #3498db;
      font-family: Arial, sans-serif;
      letter-spacing: 2px;
      animation: pulse 1.5s infinite ease-in-out;
    }

    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }


    @-webkit-keyframes load-out {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    @keyframes load-out {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }
  </style>
  <!-- Styles for the No-JavaScript message -->
  <style>
    .no-js-message {
      background: #2c4762;
      color: red;
      font-size: 20px;
      text-align: center;
      padding: 20px;
      z-index: 999999999999999999999999999999999999999999999;
      position: fixed;
      width: 100%;
      top: 0;
    }
  </style>

  <!-- No-JavaScript message -->
  <noscript>
    <div class="no-js-message">
      Please enable JavaScript to use this website properly.
    </div>
  </noscript>
  <div class="loader">
    <div class="loaderr-container">
      <div class="loaderr"></div>
      <div class="loading-text">Loading...</div>
    </div>
  </div>

  </div>
  <script>
    // This function will execute after the full page has finished loading
    window.onload = function () {
      // Trigger fade-out animation for the loader spinner
      const loaderSpinner = document.querySelector('.loaderr');
      const loadingText = document.querySelector('.loading-text');
      const loaderContainer = document.querySelector('.loader');

      // Apply animations
      loaderSpinner.style.animation = 'load-out 1.5s forwards, spin 2s linear infinite';
      loaderSpinner.style.webkitAnimation = 'load-out 1.5s forwards, spin 2s linear infinite';

      loadingText.style.animation = 'load-out 1.5s forwards, spin 2s linear infinite';
      loadingText.style.webkitAnimation = 'load-out 1.5s forwards, spin 2s linear infinite';

      loaderContainer.style.animation = 'load-out 4s forwards';
      loaderContainer.style.webkitAnimation = 'load-out 4s forwards';


    };

  </script>
  <!--______________________________END OF LOADING AND NOSCRIPT____________________________________-->
  <link rel="stylesheet" href="styles.css">

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }

    .main-menu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #000000, #542a98);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .menu-title {
      color: white;
      font-size: 2.5em;
      margin-bottom: 40px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 300px;
    }

    .menu-button {
      padding: 15px 30px;
      font-size: 1.2em;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .menu-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
    }

    .difficulty-menu {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1e3c72, #2a5298);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 10px 20px;
      font-size: 1em;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 8px;
      cursor: pointer;
    }

    .game-container {
      display: none;
      /* Hide game container initially */
    }

    .chessboard {
      width: 400px;
      height: 400px;
      border: 2px solid #333;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
    }

    .square {
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 30px;
      cursor: pointer;
    }

    .white {
      background-color: #f0d9b5;
    }

    .black {
      background-color: #b58863;
    }

    .last-move {
      background-color: #66a3ff;
    }

    .selected {
      background-color: #ffff66;
    }

    .check {
      background-color: #ff6b6b;
    }

    .controls {
      margin-top: 20px;
      text-align: center;
    }

    button {
      font-size: 16px;
      padding: 10px 20px;
      margin: 0 10px;
    }

    .status {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }

    .win-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 10px;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      z-index: 10;
    }

    .capture-log {
      margin-top: 20px;
      width: 400px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
    }

    .capture-log li {
      margin-bottom: 5px;
    }

    .white-capture {
      color: #00008B;
    }

    .black-capture {
      color: #8B0000;
    }

    .promotion-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .promotion-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .promotion-options {
      display: flex;
      justify-content: space-around;
      width: 100%;
      margin-top: 20px;
    }

    .promotion-option {
      font-size: 40px;
      cursor: pointer;
      padding: 10px;
    }

    .promotion-option:hover {
      background-color: #f0f0f0;
    }

    @media (max-width: 600px) {
      .chessboard {
        width: 300px;
        height: 300px;
      }

      .square {
        width: 37.5px;
        height: 37.5px;
        font-size: 24px;
      }

      .capture-log {
        width: 300px;
      }
    }

    .settings-button {
      position: absolute;
      top: 60px;
      right: 20px;
      font-size: 32px;
      /* Increased from 24px */
      background: #ffffff;
      border: 2px solid #333;
      border-radius: 50%;
      cursor: pointer;
      width: 50px;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.2s ease;
    }

    .settings-button:hover {
      background: #f0f0f0;
      transform: scale(1.1);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .settings-content {
      background-color: white;
      padding: 30px;
      border-radius: 10px;
      min-width: 300px;
    }

    .settings-section {
      margin-bottom: 20px;
    }

    .settings-section h3 {
      margin-bottom: 10px;
    }

    .color-palette-option {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      cursor: pointer;
    }

    .palette-preview {
      display: flex;
      margin-left: 10px;
    }

    .palette-square {
      width: 20px;
      height: 20px;
      margin-right: 2px;
    }

    /* Color palette presets */
    .theme-default .white {
      background-color: #f0d9b5;
    }

    .theme-default .black {
      background-color: #b58863;
    }

    .theme-default .last-move {
      background-color: #66a3ff;
    }

    .theme-default .selected {
      background-color: #ffff66;
    }

    .theme-default .check {
      background-color: #ff6b6b;
    }

    .theme-neon .white {
      background-color: #1a1a1a;
    }

    .theme-neon .black {
      background-color: #000000;
    }

    .theme-neon .last-move {
      background-color: #00ff00;
    }

    .theme-neon .selected {
      background-color: #ff00ff;
    }

    .theme-neon .check {
      background-color: #ff0000;
    }

    .theme-neon .square {
      color: #00ffff;
    }

    .theme-forest .white {
      background-color: #c9dbc5;
    }

    .theme-forest .black {
      background-color: #769656;
    }

    .theme-forest .last-move {
      background-color: #94bd8f;
    }

    .theme-forest .selected {
      background-color: #f7e26b;
    }

    .theme-forest .check {
      background-color: #e84855;
    }

    .possible-move-indicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: rgba(0, 0, 0, 0.2);
      position: absolute;
      pointer-events: none;
    }

    .tutorial-highlight {
      box-shadow: inset 0 0 20px rgba(255, 255, 0, 0.5);
    }

    .game-title {
      font-size: 2em;
      text-align: center;
      margin-bottom: 20px;
    }

    .game-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
    }

    .chessboard-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .capture-log {
      width: 400px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 10px;
      background-color: white;
    }

    .game-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      text-align: center;
    }

    #newGame {
      font-size: 16px;
      padding: 10px 20px;
    }

    #difficulty,
    #timer {
      font-size: 16px;
      font-weight: bold;
    }

    .status {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
    }

    @media (max-width: 600px) {
      .game-content {
        flex-direction: column;
        align-items: center;
      }

      .chessboard-container,
      .game-controls {
        align-items: center;
      }

      .capture-log {
        width: 300px;
      }
    }
  </style>
  <style>
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #f9f9f9;
      box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
    }

    .dropdown:hover .dropdown-content {
      display: block;
    }

    .dropdown-content a {
      color: black;
      text-decoration: none;
      padding: 12px 16px;
      display: block;
    }

    .dropdown-content a:hover {
      background-color: #ddd;
    }

    .navbar-toggle {
      display: none;
      background-color: #333;
      color: white;
      padding: 14px 20px;
      border: none;
      cursor: pointer;
      font-size: 18px;
    }
    button {
      padding: 10px;
      font-size: 1em;
      background-color: #000000;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: rgb(57, 200, 145);
    }
    /* Responsive styles */
    @media (max-width: 768px) {
      .nav-links {
        flex-direction: column;
        display: none;
      }

      .nav-links.show {
        display: flex;
      }

      .navbar-toggle {
        display: block;
      }
    }
  </style><script type="module" src="https://unlim8ted.com/components/site-navbar.js"></script>
      <script type="module">
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import { collection, doc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
    import { getFirebase } from "/components/firebase-init.js";

    const { auth, db } = getFirebase();</script>

</head>

<body>

   <site-navbar cart-href="https://unlim8ted.com/sign-in/cart" signin-href="https://unlim8ted.com/sign-in" profile-href="https://unlim8ted.com/profile"></site-navbar>
  <div class="main-menu" id="mainMenu">
    <h1 class="menu-title">Challenge an AI to Chess</h1>
    <div class="menu-options">
      <button class="menu-button" id="playAiBtn">Play vs AI</button>
      <button class="menu-button" id="playPlayerBtn">Play vs Player</button>
      <button class="menu-button" id="aiVsAiBtn">AI vs AI</button>
      <button class="menu-button" id="tutorialBtn">Tutorial</button>
      <button class="menu-button" id="mainSettingsBtn">Settings</button>
      <p style="color:white;" id="footer-text">&copy; 2019-2025 Unlim8ted Studio Productions. All rights reserved.</p>
            <script>document.addEventListener("DOMContentLoaded", function () {
                const currentYear = new Date().getFullYear();
                const footerText = `&copy; 2019-${currentYear} Unlim8ted Studio Productions. All rights reserved.`;
                document.getElementById("footer-text").innerHTML = footerText;
            });
            </script>
    </div>
  </div>

  <div class="difficulty-menu" id="difficultyMenu">
    <button class="back-button" id="difficultyBackBtn">← Back</button>
    <h2 class="menu-title">Select Difficulty</h2>
    <div class="menu-options">
      <button class="menu-button" data-difficulty="easy">Easy</button>
      <button class="menu-button" data-difficulty="medium">Medium</button>
      <button class="menu-button" data-difficulty="hard">Hard</button>
    </div>
  </div>

  <div class="game-container">
    <div class="game-content">
      <div class="chessboard-container">
        <div class="chessboard" id="board"></div>
        <ul class="capture-log" id="captureLog"></ul>
      </div>
      <div class="game-controls">
        <button id="newGame">New Game</button>
        <div id="difficulty">Difficulty: Easy</div>
        <div id="timer">Time: 00:00</div>
        <div class="status" id="status">Your turn (White)</div>
      </div>
    </div>

  </div>
  <button class="settings-button" id="settingsBtn">⚙️</button>


  <div class="settings-modal" id="settingsModal">
    <div class="settings-content">
      <h2>Settings</h2>

      <div class="settings-section">
        <h3>Color Palette</h3>
        <div class="color-palette-option" data-theme="default">
          <input type="radio" name="palette" value="default" checked>
          <label>Default</label>
          <div class="palette-preview">
            <div class="palette-square" style="background: #f0d9b5"></div>
            <div class="palette-square" style="background: #b58863"></div>
          </div>
        </div>
        <div class="color-palette-option" data-theme="neon">
          <input type="radio" name="palette" value="neon">
          <label>Neon</label>
          <div class="palette-preview">
            <div class="palette-square" style="background: #1a1a1a"></div>
            <div class="palette-square" style="background: #000000"></div>
          </div>
        </div>
        <div class="color-palette-option" data-theme="forest">
          <input type="radio" name="palette" value="forest">
          <label>Forest</label>
          <div class="palette-preview">
            <div class="palette-square" style="background: #c9dbc5"></div>
            <div class="palette-square" style="background: #769656"></div>
          </div>
        </div>
      </div>

      <div class="settings-section">
        <h3>Game Options</h3>
        <div>
          <input type="checkbox" id="showPossibleMoves">
          <label for="showPossibleMoves">Show possible moves</label>
        </div>
      </div>

      <button id="closeSettings">Close</button>
    </div>
  </div>

  <script>
    let currentDifficulty = 'medium';
    let gameMode = null; // 'ai', 'pvp', 'aivai', 'tutorial'
    let currentPlayer = 'white'; // For PvP mode
    let tutorialStep = 0;
    let aiVsAiInterval = null;

    const mainMenu = document.getElementById('mainMenu');
    const difficultyMenu = document.getElementById('difficultyMenu');
    const gameContainer = document.querySelector('.game-container');
    const playAiBtn = document.getElementById('playAiBtn');
    const playPlayerBtn = document.getElementById('playPlayerBtn');
    const aiVsAiBtn = document.getElementById('aiVsAiBtn');
    const tutorialBtn = document.getElementById('tutorialBtn');
    const mainSettingsBtn = document.getElementById('mainSettingsBtn');
    const difficultyBackBtn = document.getElementById('difficultyBackBtn');

    const board = document.getElementById('board');
    const status = document.getElementById('status');
    const newGameBtn = document.getElementById('newGame');
    const captureLog = document.getElementById('captureLog');

    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeSettings = document.getElementById('closeSettings');
    const showPossibleMovesCheckbox = document.getElementById('showPossibleMoves');

    const pieces = {
      'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟',
      'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'
    };

    let currentTheme = 'default';
    let showPossibleMoves = false;

    let gameState = [
      ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
      ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
      Array(8).fill(''),
      Array(8).fill(''),
      Array(8).fill(''),
      Array(8).fill(''),
      ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
      ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];

    let selectedPiece = null;
    let isPlayerTurn = true;
    let isWhiteInCheck = false;
    let isBlackInCheck = false;
    let lastMove = null;
    let capturedPieces = { white: [], black: [] };

    playAiBtn.addEventListener('click', () => {
      mainMenu.style.display = 'none';
      difficultyMenu.style.display = 'flex';
    });

    playPlayerBtn.addEventListener('click', () => {
      mainMenu.style.display = 'none';
      gameContainer.style.display = 'flex';
      initGame('pvp');
    });

    aiVsAiBtn.addEventListener('click', () => {
      mainMenu.style.display = 'none';
      gameContainer.style.display = 'flex';
      initGame('aivai');
      // Start AI vs AI moves with a delay
      aiVsAiInterval = setInterval(aiVsAiMove, 2000);
    });

    tutorialBtn.addEventListener('click', () => {
      mainMenu.style.display = 'none';
      gameContainer.style.display = 'flex';
      initGame('tutorial');
    });

    mainSettingsBtn.addEventListener('click', () => {
      mainMenu.style.display = 'none';
      settingsModal.style.display = 'flex';
    });

    difficultyBackBtn.addEventListener('click', () => {
      difficultyMenu.style.display = 'none';
      mainMenu.style.display = 'flex';
    });

    difficultyMenu.querySelectorAll('[data-difficulty]').forEach(button => {
      button.addEventListener('click', (e) => {
        currentDifficulty = e.target.dataset.difficulty;
        difficultyMenu.style.display = 'none';
        gameContainer.style.display = 'flex';
        initGame('ai');
      });
    });

    // Add new function to initialize game based on mode
    function initGame(mode) {
      gameMode = mode;
      gameState = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        Array(8).fill(''),
        Array(8).fill(''),
        Array(8).fill(''),
        Array(8).fill(''),
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
      ];
      selectedPiece = null;
      isPlayerTurn = true;
      currentPlayer = 'white';
      isWhiteInCheck = false;
      isBlackInCheck = false;
      lastMove = null;
      capturedPieces = { white: [], black: [] };
      tutorialStep = 0;

      if (aiVsAiInterval) {
        clearInterval(aiVsAiInterval);
        aiVsAiInterval = null;
      }

      renderBoard();
      updateStatusForMode();
      captureLog.innerHTML = '';

      if (mode === 'aivai') {
        isPlayerTurn = false;
        aiVsAiInterval = setInterval(aiVsAiMove, 2000);
      } else if (mode === 'tutorial') {
        showTutorialStep();
      }
    }

    const tutorialSteps = [
      {
        message: "Welcome to Chess! First, let's learn about the pieces.",
        board: [
          ['', '', '', '', 'k', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', '', '', '', ''],
          ['', '', '', '', 'K', '', '', '']
        ],
        highlight: [{ row: 7, col: 4 }]
      },
      // Add more tutorial steps here
    ];

    function showTutorialStep() {
      if (tutorialStep >= tutorialSteps.length) {
        alert("Tutorial complete! Ready to play?");
        mainMenu.style.display = 'flex';
        gameContainer.style.display = 'none';
        return;
      }

      const step = tutorialSteps[tutorialStep];
      gameState = step.board;
      status.textContent = step.message;
      renderBoard();

      // Highlight relevant squares
      if (step.highlight) {
        step.highlight.forEach(pos => {
          const square = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
          if (square) square.classList.add('tutorial-highlight');
        });
      }
    }

    // Add tutorial navigation
    function nextTutorialStep() {
      tutorialStep++;
      showTutorialStep();
    }

    // Updated handleClick function
    function handleClick(e) {
      if (gameMode === 'tutorial') {
        nextTutorialStep();
        return;
      }

      if (gameMode === 'aivai') return;

      if (gameMode === 'pvp') {
        handlePvPClick(e);
        return;
      }

      // AI game logic
      if (!isPlayerTurn) return;

      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);

      const piece = gameState[row][col];

      if (selectedPiece) {
        if (isValidMove(selectedPiece, row, col)) {
          const capturedPiece = gameState[row][col];
          movePiece(selectedPiece, row, col);

          // Check if move puts own king in check
          if (isKingInCheck('white')) {
            // Undo move
            gameState[selectedPiece.row][selectedPiece.col] = gameState[row][col];
            gameState[row][col] = capturedPiece;
            selectedPiece = null;
            status.textContent = "Invalid move. Your king would be in check!";
            renderBoard();
            return;
          }

          if (capturedPiece) {
            logCapture(gameState[row][col], capturedPiece);
            capturedPieces.black.push(capturedPiece.toLowerCase());
          }

          // Check for pawn promotion
          if (gameState[row][col] === 'P' && row === 0) {
            showPromotionModal(row, col);
            return;
          }

          if (capturedPiece.toLowerCase() === 'k') {
            displayWinMessage('White');
            return;
          }

          lastMove = { from: selectedPiece, to: { row, col } };
          selectedPiece = null;
          isPlayerTurn = false;
          isBlackInCheck = isKingInCheck('black');
          isWhiteInCheck = false;
          status.textContent = isBlackInCheck ? "Black is in check! AI is thinking..." : "AI is thinking...";
          renderBoard();
          setTimeout(aiMove, 1000);
        }
        selectedPiece = null;
      } else if (piece && piece === piece.toUpperCase()) {
        selectedPiece = { row, col };
      }

      renderBoard();
    }

    // Helper function to prevent errors with undefined pieces
    function logCapture(capturingPiece, capturedPiece) {
      if (!capturingPiece || !capturedPiece) return;

      const logEntry = document.createElement('li');
      logEntry.textContent = `${pieces[capturingPiece]} captured ${pieces[capturedPiece]}`;
      logEntry.className = capturingPiece === capturingPiece.toUpperCase() ? 'white-capture' : 'black-capture';
      captureLog.insertBefore(logEntry, captureLog.firstChild);
    }

    function handlePvPClick(e) {
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);

      const piece = gameState[row][col];
      const isPieceWhite = piece === piece.toUpperCase();

      if (selectedPiece) {
        if (isValidMove(selectedPiece, row, col)) {
          const capturedPiece = gameState[row][col];
          movePiece(selectedPiece, row, col);

          // Check if move puts own king in check
          if ((currentPlayer === 'white' && isKingInCheck('white')) ||
            (currentPlayer === 'black' && isKingInCheck('black'))) {
            // Undo move
            gameState[selectedPiece.row][selectedPiece.col] = gameState[row][col];
            gameState[row][col] = capturedPiece;
            selectedPiece = null;
            status.textContent = "Invalid move. Your king would be in check!";
            renderBoard();
            return;
          }

          if (capturedPiece) {
            logCapture(gameState[row][col], capturedPiece);
          }

          currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
          updateStatusForMode();
        }
        selectedPiece = null;
      } else if (piece && ((currentPlayer === 'white' && isPieceWhite) ||
        (currentPlayer === 'black' && !isPieceWhite))) {
        selectedPiece = { row, col };
      }

      renderBoard();
    }

    function updateStatusForMode() {
      switch (gameMode) {
        case 'pvp':
          status.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
          break;
        case 'aivai':
          status.textContent = "AI vs AI match in progress...";
          break;
        case 'ai':
          status.textContent = isPlayerTurn ? "Your turn (White)" : "AI is thinking...";
          break;
      }
    }

    function aiMove() {
      const moveDelay = {
        'easy': 1000,
        'medium': 2000,
        'hard': 3000
      }[currentDifficulty];

      const makeOptimalMove = Math.random() > {
        'easy': 0.5,
        'medium': 0.2,
        'hard': 0.05
      }[currentDifficulty];

      const blackPieces = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (gameState[i][j] && gameState[i][j] === gameState[i][j].toLowerCase()) {
            blackPieces.push({ row: i, col: j });
          }
        }
      }

      let captureMoves = [];
      let validMoves = [];

      for (const piece of blackPieces) {
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (isValidMove(piece, i, j)) {
              const move = { from: piece, to: { row: i, col: j } };
              // Simulate the move
              const capturedPiece = gameState[i][j];
              gameState[i][j] = gameState[piece.row][piece.col];
              gameState[piece.row][piece.col] = '';

              if (!isKingInCheck('black')) {
                if (capturedPiece && capturedPiece === capturedPiece.toUpperCase()) {
                  captureMoves.push(move);
                } else {
                  validMoves.push(move);
                }
              }

              // Undo the move
              gameState[piece.row][piece.col] = gameState[i][j];
              gameState[i][j] = capturedPiece;
            }
          }
        }
      }

      let selectedMove;
      if (captureMoves.length > 0) {
        selectedMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
      } else if (validMoves.length > 0) {
        selectedMove = validMoves[Math.floor(Math.random() * validMoves.length)];
      }

      if (selectedMove) {
        const capturedPiece = gameState[selectedMove.to.row][selectedMove.to.col];
        movePiece(selectedMove.from, selectedMove.to.row, selectedMove.to.col);
        lastMove = selectedMove;
        if (capturedPiece) {
          logCapture(gameState[selectedMove.to.row][selectedMove.to.col], capturedPiece);
          capturedPieces.white.push(capturedPiece.toUpperCase());
        }

        // Check for pawn promotion
        if (gameState[selectedMove.to.row][selectedMove.to.col] === 'p' && selectedMove.to.row === 7) {
          const promotionPieces = ['q', 'b', 'n', 'r'];
          for (const piece of promotionPieces) {
            if (capturedPieces.white.includes(piece.toUpperCase())) {
              gameState[selectedMove.to.row][selectedMove.to.col] = piece;
              capturedPieces.white.splice(capturedPieces.white.indexOf(piece.toUpperCase()), 1);
              break;
            }
          }
          if (gameState[selectedMove.to.row][selectedMove.to.col] === 'p') {
            gameState[selectedMove.to.row][selectedMove.to.col] = 'q'; // Default to queen if no captured pieces
          }
        }

        if (capturedPiece && capturedPiece.toUpperCase() === 'K') {
          displayWinMessage('Black');
          return;
        }
      }

      isWhiteInCheck = isKingInCheck('white');
      isBlackInCheck = false;
      renderBoard();
      isPlayerTurn = true;
      status.textContent = isWhiteInCheck ? "Your king is in check! Your turn (White)" : "Your turn (White)";
    }

    function isValidMove(from, toRow, toCol) {
      // Validate parameters
      if (!from || typeof toRow !== 'number' || typeof toCol !== 'number' ||
        toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {
        return false;
      }

      const piece = gameState[from.row][from.col].toLowerCase();
      const dx = toCol - from.col;
      const dy = toRow - from.row;
      const isWhite = gameState[from.row][from.col] === gameState[from.row][from.col].toUpperCase();
      const targetPiece = gameState[toRow][toCol] || '';  // Ensure targetPiece is never undefined

      if (targetPiece && (isWhite === (targetPiece === targetPiece.toUpperCase()))) {
        return false;
      }

      switch (piece) {
        case 'p':
          if (isWhite) {
            if (from.row === 6) {
              return (dy === -1 && dx === 0 && !targetPiece) ||
                (dy === -2 && dx === 0 && !targetPiece && !gameState[from.row - 1][from.col]) ||
                (dy === -1 && Math.abs(dx) === 1 && targetPiece);
            } else {
              return (dy === -1 && dx === 0 && !targetPiece) ||
                (dy === -1 && Math.abs(dx) === 1 && targetPiece);
            }
          } else {
            if (from.row === 1) {
              return (dy === 1 && dx === 0 && !targetPiece) ||
                (dy === 2 && dx === 0 && !targetPiece && !gameState[from.row + 1][from.col]) ||
                (dy === 1 && Math.abs(dx) === 1 && targetPiece);
            } else {
              return (dy === 1 && dx === 0 && !targetPiece) ||
                (dy === 1 && Math.abs(dx) === 1 && targetPiece);
            }
          }
        case 'r':
          return (dx === 0 || dy === 0) && isPathClear(from, toRow, toCol);
        case 'n':
          return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);
        case 'b':
          return Math.abs(dx) === Math.abs(dy) && isPathClear(from, toRow, toCol);
        case 'q':
          return (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) && isPathClear(from, toRow, toCol);
        case 'k':
          return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;
        default:
          return false;
      }
    }

    function isKingInCheck(color) {
      if (!color || (color !== 'white' && color !== 'black')) {
        return false;
      }

      // Find the king's position
      let kingPos = null;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (gameState[i][j].toLowerCase() === 'k' &&
            (color === 'white' ? gameState[i][j] === 'K' :
              gameState[i][j] === 'k')) {
            kingPos = { row: i, col: j };
            break;
          }
        }
        if (kingPos) break;
      }

      if (!kingPos) return false;

      // Check if any opponent's piece can capture the king
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = gameState[i][j];
          if (piece &&
            (color === 'white' ? piece === piece.toLowerCase() :
              piece === piece.toUpperCase())) {
            if (isValidMove({ row: i, col: j }, kingPos.row, kingPos.col)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    function isPathClear(from, toRow, toCol) {
      const dx = Math.sign(toCol - from.col);
      const dy = Math.sign(toRow - from.row);
      let x = from.col + dx;
      let y = from.row + dy;

      while (x !== toCol || y !== toRow) {
        if (gameState[y][x] !== '') {
          return false;
        }
        x += dx;
        y += dy;
      }

      return true;
    }

    function movePiece(from, toRow, toCol) {
      gameState[toRow][toCol] = gameState[from.row][from.col];
      gameState[from.row][from.col] = '';
    }

    function aiVsAiMove() {
      if (gameMode !== 'aivai') return;

      const isWhiteTurn = currentPlayer === 'white';
      const blackPieces = [];
      const whitePieces = [];

      // Gather all pieces
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const piece = gameState[i][j];
          if (piece) {
            if (piece === piece.toLowerCase()) {
              blackPieces.push({ row: i, col: j });
            } else {
              whitePieces.push({ row: i, col: j });
            }
          }
        }
      }

      // Select pieces based on current turn
      const pieces = isWhiteTurn ? whitePieces : blackPieces;
      let validMoves = [];
      let captureMoves = [];

      // Find all valid moves
      for (const piece of pieces) {
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (isValidMove(piece, i, j)) {
              const move = { from: piece, to: { row: i, col: j } };
              const capturedPiece = gameState[i][j];

              if (capturedPiece) {
                captureMoves.push(move);
              } else {
                validMoves.push(move);
              }
            }
          }
        }
      }

      // Make a move
      const moves = captureMoves.length > 0 ? captureMoves : validMoves;
      if (moves.length > 0) {
        const move = moves[Math.floor(Math.random() * moves.length)];
        const capturedPiece = gameState[move.to.row][move.to.col];

        movePiece(move.from, move.to.row, move.to.col);
        lastMove = move;

        if (capturedPiece) {
          logCapture(gameState[move.to.row][move.to.col], capturedPiece);
          if (isWhiteTurn) {
            capturedPieces.black.push(capturedPiece.toLowerCase());
          } else {
            capturedPieces.white.push(capturedPiece.toUpperCase());
          }
        }
      }

      // Update game state
      currentPlayer = isWhiteTurn ? 'black' : 'white';
      isWhiteInCheck = isKingInCheck('white');
      isBlackInCheck = isKingInCheck('black');

      renderBoard();
      updateStatusForMode();

      // Check for checkmate or stalemate
      if (moves.length === 0) {
        displayWinMessage(isWhiteTurn ? 'Black' : 'White');
        clearInterval(aiVsAiInterval);
        return;
      }
    }

    function displayWinMessage(winner) {
      const winMessage = document.createElement('div');
      winMessage.className = 'win-message';
      winMessage.textContent = `${winner} wins!`;
      document.body.appendChild(winMessage);
    }

    function showPromotionModal(row, col) {
      const modal = document.createElement('div');
      modal.className = 'promotion-modal';

      const content = document.createElement('div');
      content.className = 'promotion-content';
      content.innerHTML = '<h2>Choose a piece for promotion:</h2>';

      const options = document.createElement('div');
      options.className = 'promotion-options';

      const availablePieces = capturedPieces.black.length > 0 ? capturedPieces.black : ['q', 'r', 'b', 'n'];

      availablePieces.forEach(piece => {
        const option = document.createElement('div');
        option.className = 'promotion-option';
        option.textContent = pieces[piece.toUpperCase()];
        option.addEventListener('click', () => {
          gameState[row][col] = piece.toUpperCase();
          if (capturedPieces.black.includes(piece)) {
            capturedPieces.black.splice(capturedPieces.black.indexOf(piece), 1);
          }
          modal.remove();
          isPlayerTurn = false;
          isBlackInCheck = isKingInCheck('black');
          isWhiteInCheck = false;
          status.textContent = isBlackInCheck ? "Black is in check! AI is thinking..." : "AI is thinking...";
          renderBoard();
          setTimeout(aiMove, 3000);
        });
        options.appendChild(option);
      });

      content.appendChild(options);
      modal.appendChild(content);
      document.body.appendChild(modal);
    }

    newGameBtn.addEventListener('click', () => {
      gameContainer.style.display = 'none';
      mainMenu.style.display = 'flex';
      const winMessage = document.querySelector('.win-message');
      if (winMessage) {
        winMessage.remove();
      }
    });

    settingsBtn.addEventListener('click', () => {
      settingsModal.style.display = 'flex';
    });

    closeSettings.addEventListener('click', () => {
      settingsModal.style.display = 'none';
      mainMenu.style.display = 'flex'; // Show main menu again when closing settings
    });

    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) {
        settingsModal.style.display = 'none';
        mainMenu.style.display = 'flex'; // Show main menu again when closing settings
      }
    });

    // Color palette selection
    document.querySelectorAll('.color-palette-option').forEach(option => {
      option.addEventListener('click', () => {
        const theme = option.dataset.theme;
        currentTheme = theme;
        document.querySelector('.chessboard').className = `chessboard theme-${theme}`;
        option.querySelector('input').checked = true;
        renderBoard();
      });
    });

    // Show possible moves toggle
    showPossibleMovesCheckbox.addEventListener('change', (e) => {
      showPossibleMoves = e.target.checked;
      if (!showPossibleMoves) {
        removePossibleMoveIndicators();
      } else if (selectedPiece) {
        showPossibleMovesForPiece(selectedPiece);
      }
    });

    function removePossibleMoveIndicators() {
      document.querySelectorAll('.possible-move-indicator').forEach(indicator => indicator.remove());
    }

    function showPossibleMovesForPiece(piece) {
      removePossibleMoveIndicators();
      if (!showPossibleMoves) return;

      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (isValidMove(piece, i, j)) {
            const square = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
            const indicator = document.createElement('div');
            indicator.className = 'possible-move-indicator';
            square.appendChild(indicator);
          }
        }
      }
    }

    // Modify the handleClick function to include possible moves
    const originalHandleClick = handleClick;
    handleClick = function (e) {
      originalHandleClick.call(this, e);
      if (selectedPiece && showPossibleMoves) {
        showPossibleMovesForPiece(selectedPiece);
      }
    };

    // New renderBoard function
    function renderBoard() {
      // Clear existing board
      board.innerHTML = '';

      // Add squares to the board
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const square = document.createElement('div');
          square.className = `square ${(i + j) % 2 === 0 ? 'white' : 'black'}`;
          square.dataset.row = i;
          square.dataset.col = j;

          // Add chess piece if present
          const piece = gameState[i][j];
          if (piece) {
            square.textContent = pieces[piece];
          }

          // Add selected piece highlight
          if (selectedPiece && selectedPiece.row === i && selectedPiece.col === j) {
            square.classList.add('selected');
          }

          // Add last move highlight
          if (lastMove &&
            ((lastMove.from.row === i && lastMove.from.col === j) ||
              (lastMove.to.row === i && lastMove.to.col === j))) {
            square.classList.add('last-move');
          }

          // Add check highlight
          if ((isWhiteInCheck && piece === 'K') ||
            (isBlackInCheck && piece === 'k')) {
            square.classList.add('check');
          }

          square.addEventListener('click', handleClick);
          board.appendChild(square);
        }
      }

      // Add theme class to board
      board.className = `chessboard theme-${currentTheme}`;

      // Show possible moves if enabled
      if (showPossibleMoves && selectedPiece) {
        showPossibleMovesForPiece(selectedPiece);
      }
    }

    renderBoard();
  </script>
</body>

</html>
