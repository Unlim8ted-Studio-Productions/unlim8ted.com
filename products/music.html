<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Unlim8ted - Music</title>
  <link rel="icon" href="https://unlim8ted.com/favicon.ico" type="image/x-icon" />
  <meta name="description"
    content="Unlim8ted Music. Great music made by Unlim8ted Studio Productions. Always free, no signup required. Powered by Unlim8ted Studio Productions." />

  <!-- Modern navbar web component -->
  <script type="module" src="/components/site-navbar.js"></script>

  <!-- MIDI parser -->
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>

  <style>
    :root {
      --bg0: #05040a;
      --bg1: #0c0620;
      --ink: rgba(233, 231, 255, .92);
      --muted: rgba(233, 231, 255, .72);
      --glass: rgba(0, 0, 0, .38);
      --stroke: rgba(180, 130, 255, .22);
      --accent: rgba(184, 107, 255, .95);
      --accent2: rgba(103, 213, 255, .85);
      --good: rgba(57, 200, 145, 1);
      --bad: rgba(255, 120, 120, .95);
      --shadow: 0 18px 70px rgba(0, 0, 0, .55);
      --radius: 18px;
      --radius2: 24px;
      --maxw: 1200px;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 700px at 15% 15%, rgba(184, 107, 255, .22), transparent 60%),
        radial-gradient(900px 600px at 85% 30%, rgba(103, 213, 255, .18), transparent 60%),
        linear-gradient(145deg, var(--bg1), var(--bg0));
      overflow: hidden;
    }

    /* ===== Loader ===== */
    .loader {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 999999988;
      pointer-events: none;
      display: grid;
      place-items: center;
      opacity: 1;
    }

    .loaderr-container {
      display: grid;
      place-items: center;
      gap: 16px;
      padding: 24px;
      text-align: center;
    }

    .loaderr {
      width: 92px;
      height: 92px;
      border-radius: 50%;
      border: 8px solid transparent;
      border-top: 8px solid #3498db;
      border-right: 8px solid #e74c3c;
      border-bottom: 8px solid #f1c40f;
      border-left: 8px solid #9b59b6;
      animation: spin 1.25s linear infinite;
      box-shadow:
        0 0 18px rgba(52, 152, 219, .55),
        0 0 18px rgba(231, 76, 60, .55),
        0 0 18px rgba(241, 196, 15, .55),
        0 0 18px rgba(155, 89, 182, .55);
      position: relative;
    }

    .loaderr:before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 8px solid transparent;
      border-top: 8px solid rgba(52, 152, 219, 0.55);
      border-right: 8px solid rgba(231, 76, 60, 0.55);
      border-bottom: 8px solid rgba(241, 196, 15, 0.55);
      border-left: 8px solid rgba(155, 89, 182, 0.55);
      animation: spin-reverse 1.25s linear infinite;
    }

    .loading-text {
      font-size: 14px;
      letter-spacing: .2em;
      text-transform: uppercase;
      color: rgba(233, 231, 255, .75);
      animation: pulse 1.35s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @keyframes spin-reverse {
      to {
        transform: rotate(-360deg);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: .55;
      }
    }

    @keyframes load-out {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* No-JS message */
    .no-js-message {
      background: #2c4762;
      color: #ff4a4a;
      font-size: 18px;
      text-align: center;
      padding: 16px;
      z-index: 999999999999;
      position: fixed;
      width: 100%;
      top: 0;
      left: 0;
    }

    /* ===== Page Layout ===== */
    .shell {
      height: calc(100vh - var(--navSpace, 56px));
      width: min(var(--maxw), calc(100% - 28px));
      margin: 14px auto;
      display: grid;
      grid-template-columns: 1.15fr 2fr;
      gap: 14px;
    }

    .panel {
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      background: rgba(10, 8, 18, .48);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      overflow: hidden;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, .08);
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), transparent);
    }

    .title {
      margin: 0;
      font-size: 16px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(233, 231, 255, .85);
      font-weight: 900;
    }

    .subtitle {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }

    /* ===== Left: Song list ===== */
    .song-list {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 1rem;
      box-sizing: border-box;
      scroll-behavior: smooth;
      overscroll-behavior: contain;
      scrollbar-width: thin;
      scrollbar-color: rgba(184, 107, 255, 0.55) transparent;
    }

    .song-list::-webkit-scrollbar {
      width: 10px;
    }

    .song-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .song-list::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(184, 107, 255, 0.9), rgba(103, 213, 255, 0.7));
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    .song-list::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(57, 200, 145, 0.95), rgba(103, 213, 255, 0.85));
    }

    .song-item {
      border: 1px solid rgba(180, 130, 255, .22);
      border-radius: 16px;
      padding: 12px 12px;
      margin: 10px 0;
      background: rgba(0, 0, 0, .22);
      cursor: pointer;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
      display: grid;
      gap: 8px;
      position: relative;
      outline: none;
    }

    .song-item:hover {
      transform: translateY(-1px);
      border-color: rgba(184, 107, 255, .40);
      background: rgba(255, 255, 255, .06);
    }

    .song-item.playing {
      border-color: rgba(57, 200, 145, .70);
      background: rgba(57, 200, 145, .10);
      box-shadow: 0 0 0 2px rgba(57, 200, 145, .10) inset;
    }

    .song-item.playing::after {
      content: "Now Playing";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 11px;
      letter-spacing: .08em;
      text-transform: uppercase;
      font-weight: 900;
      color: rgba(9, 8, 14, .95);
      background: rgba(57, 200, 145, .95);
      padding: 6px 10px;
      border-radius: 999px;
    }

    .song-name {
      font-weight: 900;
      font-size: 15px;
      color: rgba(233, 231, 255, .92);
    }

    .song-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(255, 255, 255, .06);
      color: rgba(233, 231, 255, .86);
      text-decoration: none;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: .04em;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
      user-select: none;
    }

    .pill:hover {
      transform: translateY(-1px);
      border-color: rgba(57, 200, 145, .45);
      background: rgba(57, 200, 145, .10);
    }

    .pill-btn {
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .06);
    }

    .now-playing {
      font-size: 12px;
      color: rgba(233, 231, 255, .65);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .footer {
      padding: 14px 14px 16px;
      border-top: 1px solid rgba(255, 255, 255, .08);
      color: rgba(233, 231, 255, .60);
      font-size: 12px;
      text-align: center;
    }

    /* ===== Section divider (TimeCat) ===== */
    .section-divider {
      margin: 18px 0 8px;
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(180, 130, 255, .18);
      background: rgba(0, 0, 0, .16);
      display: grid;
      gap: 6px;
    }

    .section-kicker {
      font-size: 11px;
      letter-spacing: .22em;
      text-transform: uppercase;
      color: rgba(233, 231, 255, .65);
      font-weight: 900;
    }

    .section-title {
      font-size: 14px;
      font-weight: 950;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: rgba(233, 231, 255, .92);
    }

    .section-sub {
      font-size: 12px;
      color: rgba(233, 231, 255, .70);
      line-height: 1.4;
    }

    /* ===== Right: Visualizer ===== */
    .visualizer-wrap {
      display: grid;
      grid-template-rows: auto 1fr auto auto;
      min-height: 0;
      background: rgba(0, 0, 0, .60);
    }

    #midiCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      display: grid;
      gap: 10px;
      padding: 12px;
      border-top: 1px solid rgba(255, 255, 255, .08);
      background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(0, 0, 0, .25));
    }

    .controls-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .btn {
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .06);
      color: rgba(233, 231, 255, .92);
      cursor: pointer;
      font-weight: 900;
      letter-spacing: .04em;
      transition: transform .18s ease, background .18s ease, border-color .18s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      border-color: rgba(57, 200, 145, .45);
      background: rgba(57, 200, 145, .10);
    }

    .btn.ghost {
      border-color: rgba(255, 255, 255, .10);
      background: rgba(0, 0, 0, .18);
      color: rgba(233, 231, 255, .75);
    }

    .range {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .10);
      outline: none;
      cursor: pointer;
      width: 100%;
      max-width: 520px;
    }

    .range::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(233, 231, 255, .95);
      border: 2px solid rgba(184, 107, 255, .65);
      box-shadow: 0 8px 18px rgba(0, 0, 0, .35);
    }

    .range::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(233, 231, 255, .95);
      border: 2px solid rgba(184, 107, 255, .65);
      box-shadow: 0 8px 18px rgba(0, 0, 0, .35);
    }

    .small {
      font-size: 12px;
      color: rgba(233, 231, 255, .70);
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .chip {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, .10);
      background: rgba(255, 255, 255, .06);
    }

    /* ===== Epilepsy warning ===== */
    .warning {
      border-top: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 160, 80, .10);
      padding: 10px 12px;
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: space-between;
    }

    .warning strong {
      color: rgba(255, 215, 165, .98);
      letter-spacing: .06em;
      text-transform: uppercase;
      font-size: 12px;
    }

    .warning p {
      margin: 4px 0 0;
      font-size: 12px;
      color: rgba(233, 231, 255, .72);
      line-height: 1.35;
    }

    /* ===== Reviews ===== */
    .reviews {
      border-top: 1px solid rgba(255, 255, 255, .08);
      padding: 12px;
      display: grid;
      gap: 12px;
      min-height: 0;
      background: rgba(0, 0, 0, .35);
    }

    .reviewsHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stars {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      letter-spacing: .12em;
      color: rgba(255, 204, 102, .95);
      user-select: none;
      white-space: nowrap;
    }

    .avgWrap {
      display: flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .avgNum {
      font-size: 26px;
      font-weight: 950;
      line-height: 1;
    }

    .avgMeta {
      display: grid;
      gap: 2px;
    }

    .muted {
      color: rgba(233, 231, 255, .65);
      font-size: 12px;
    }

    .bars {
      display: grid;
      gap: 8px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .04);
    }

    .barRow {
      display: grid;
      grid-template-columns: 72px 1fr 34px;
      gap: 10px;
      align-items: center;
      font-size: 12px;
      color: rgba(233, 231, 255, .70);
    }

    .barTrack {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .08);
      overflow: hidden;
    }

    .barFill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(184, 107, 255, .90), rgba(103, 213, 255, .75));
    }

    .commentList {
      max-height: 220px;
      overflow: auto;
      padding-right: 6px;
      scrollbar-width: thin;
      scrollbar-color: rgba(184, 107, 255, 0.55) transparent;
    }

    .commentList::-webkit-scrollbar {
      width: 10px;
    }

    .commentList::-webkit-scrollbar-track {
      background: transparent;
    }

    .commentList::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(184, 107, 255, 0.9), rgba(103, 213, 255, 0.7));
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    .comment {
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(0, 0, 0, .22);
      border-radius: 16px;
      padding: 10px 10px;
      margin: 10px 0;
      display: grid;
      gap: 8px;
    }

    .commentTop {
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .who {
      font-weight: 900;
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .when {
      font-size: 12px;
      color: rgba(233, 231, 255, .55);
    }

    .commentText {
      margin: 0;
      font-size: 13px;
      color: rgba(233, 231, 255, .78);
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .mineBadge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(57, 200, 145, .35);
      background: rgba(57, 200, 145, .12);
      color: rgba(57, 200, 145, .95);
      font-size: 11px;
      font-weight: 900;
      letter-spacing: .06em;
      text-transform: uppercase;
    }

    .empty {
      padding: 12px;
      border-radius: 16px;
      border: 1px dashed rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .03);
      color: rgba(233, 231, 255, .65);
      font-size: 13px;
    }

    .commentForm {
      display: none;
      gap: 10px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .03);
      padding: 12px;
      border-radius: 16px;
    }

    .fieldRow {
      display: grid;
      grid-template-columns: 1fr 140px;
      gap: 10px;
      align-items: center;
    }

    .input,
    .select,
    .textarea {
      width: 100%;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(0, 0, 0, .20);
      color: rgba(233, 231, 255, .92);
      padding: 10px 12px;
      outline: none;
      font-weight: 700;
    }

    .textarea {
      min-height: 90px;
      resize: vertical;
      font-weight: 650;
      line-height: 1.35;
    }

    .formMsg {
      font-size: 12px;
      color: rgba(233, 231, 255, .65);
    }

    @media (max-width: 900px) {
      body {
        overflow: auto;
      }

      .shell {
        height: auto;
        grid-template-columns: 1fr;
        margin-bottom: 18px;
      }

      .panel {
        min-height: 420px;
      }

      .visualizer-wrap {
        min-height: 520px;
      }

      .fieldRow {
        grid-template-columns: 1fr;
      }
    }

    @media (prefers-reduced-motion: reduce) {

      *,
      *::before,
      *::after {
        animation: none !important;
        transition: none !important;
        scroll-behavior: auto !important;
      }
    }

    /* Song list max-height rules */
    .song-list {
      max-height: 90vh;
      /* not-mobile: 1/3 viewport height */
    }

    /* mobile: cap to half the viewport */
    @media (max-width: 900px) {
      .song-list {
        max-height: 32vh;
      }
    }/* =========================
   Pretty checkbox (Autoplay)
   ========================= */
.controls input[type="checkbox"]{
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.06);
  box-shadow: 0 10px 25px rgba(0,0,0,.35);
  display: inline-grid;
  place-content: center;
  cursor: pointer;
  transition: transform .14s ease, background .14s ease, border-color .14s ease, box-shadow .14s ease;
}

.controls input[type="checkbox"]:hover{
  transform: translateY(-1px);
  border-color: rgba(57, 200, 145, .45);
  background: rgba(57, 200, 145, .10);
}

.controls input[type="checkbox"]:focus-visible{
  outline: none;
  box-shadow:
    0 0 0 3px rgba(184, 107, 255, .25),
    0 10px 25px rgba(0,0,0,.35);
}

/* The checkmark */
.controls input[type="checkbox"]::before{
  content: "";
  width: 10px;
  height: 6px;
  border-left: 3px solid rgba(9, 8, 14, .95);
  border-bottom: 3px solid rgba(9, 8, 14, .95);
  transform: rotate(-45deg) scale(0);
  transform-origin: center;
  transition: transform .14s ease;
}

/* Checked state */
.controls input[type="checkbox"]:checked{
  border-color: rgba(57, 200, 145, .70);
  background: rgba(57, 200, 145, .95);
  box-shadow:
    0 0 0 2px rgba(57, 200, 145, .18) inset,
    0 10px 25px rgba(0,0,0,.35);
}

.controls input[type="checkbox"]:checked::before{
  transform: rotate(-45deg) scale(1);
}

/* Disabled */
.controls input[type="checkbox"]:disabled{
  opacity: .55;
  cursor: not-allowed;
  transform: none;
}

  </style>

  <noscript>
    <div class="no-js-message">Please enable JavaScript to use this website properly.</div>
  </noscript>

  <div class="loader" id="loader">
    <div class="loaderr-container">
      <div class="loaderr"></div>
      <div class="loading-text">Loading...</div>
    </div>
  </div>

  <script>
    window.onload = function () {
      const loader = document.getElementById("loader");
      if (!loader) return;
      loader.style.animation = "load-out 0.9s ease forwards";
      setTimeout(() => loader.remove(), 950);
    };
  </script>
</head>

<body>
  <site-navbar base="" cart-href="/cart" signin-href="https://unlim8ted.com/sign-in"
    profile-href="https://unlim8ted.com/profile"></site-navbar>

  <div class="shell" id="shell">
    <!-- Left panel -->
    <section class="panel">
      <div class="panel-header">
        <div>
          <h2 class="title">Music</h2>
          <p class="subtitle">Pick a track to play. PDFs open in a new tab.</p>
        </div>
        <div class="now-playing" id="nowPlaying">Nothing playing</div>
      </div>

      <div class="song-list" id="songList">
        <!-- Built from /tools/data/products.json -->
        <div class="empty">Loading tracks…</div>
      </div>

      <div class="footer">
        <p id="footer-text">&copy; 2019-2025 Unlim8ted Studio Productions. All rights reserved.</p>
      </div>
    </section>

    <!-- Right panel -->
    <section class="panel visualizer-wrap">
      <div class="panel-header">
        <div>
          <h2 class="title">Visualizer</h2>
          <p class="subtitle" id="vizSubtitle">MIDI notes falling in real-time.</p>
        </div>
        <div class="small">
          <span class="chip" id="statusChip">Idle</span>
          <span class="chip" id="timeChip">0:00</span>
        </div>
      </div>

      <canvas id="midiCanvas"></canvas>

      <!-- Epilepsy warning (dismissible) -->
      <div class="warning" id="epWarn" style="display:none;">
        <div>
          <strong>Photosensitivity warning</strong>
          <p>This visualizer contains flashing / rapidly changing visuals that may trigger seizures for people with
            photosensitive epilepsy. Use caution, reduce brightness, or disable playback if sensitive.</p>
        </div>
        <button class="btn ghost" id="dismissWarn" type="button">Dismiss</button>
      </div>

      <div class="controls">
        <div class="controls-row">
          <button class="btn" id="pauseBtn" type="button">Pause</button>
          <button class="btn" id="playBtn" type="button">Play</button>
          <button class="btn" id="restartBtn" type="button">Restart</button>
        </div>

        <input class="range" type="range" id="timeline" min="0" max="100" value="0" step="1" aria-label="Timeline" />

        <div class="controls-row">
          <div class="small">Volume</div>
          <input class="range" type="range" id="volume" min="0" max="1" step="0.01" value="1"
            aria-label="Volume" />
        </div>

        <div class="controls-row">
          <div class="small">Autoplay next</div>
          <label class="small" style="gap:10px;">
            <input type="checkbox" id="autoplayNext" checked />
            On
          </label>
        </div>
      </div>

      <!-- Reviews / Ratings -->
      <div class="reviews">
        <div class="reviewsHead">
          <div class="avgWrap">
            <div class="avgNum" id="avgNum">—</div>
            <div class="avgMeta">
              <div class="stars" id="avgStarsBig">☆☆☆☆☆</div>
              <div class="muted" id="avgLabel">Select a track</div>
              <div class="muted" id="countLabel">0 reviews</div>
            </div>
          </div>
          <div class="stars" id="avgStars">☆☆☆☆☆</div>
        </div>

        <div class="bars" id="bars"></div>

        <div class="commentList" id="commentList">
          <div class="empty">Select a track to view reviews.</div>
        </div>

        <div class="empty" id="mustSignIn" style="display:none;">
          Sign in to post a rating and review.
        </div>

        <form class="commentForm" id="commentForm">
          <div class="fieldRow">
            <input class="input" id="displayName" maxlength="80" placeholder="Display name (optional)" />
            <select class="select" id="ratingSel" aria-label="Rating">
              <option value="5">★★★★★ (5)</option>
              <option value="4">★★★★☆ (4)</option>
              <option value="3">★★★☆☆ (3)</option>
              <option value="2">★★☆☆☆ (2)</option>
              <option value="1">★☆☆☆☆ (1)</option>
            </select>
          </div>

          <textarea class="textarea" id="commentText" maxlength="2000"
            placeholder="Write a review (max 2000 chars)…"></textarea>

          <div class="controls-row">
            <div class="formMsg" id="formMsg"></div>
            <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
              <button class="btn ghost" type="button" id="deleteMyReviewBtn" style="display:none;">Delete my
                review</button>
              <button class="btn" type="submit" id="postBtn">Post</button>
            </div>
          </div>
        </form>
      </div>
    </section>
  </div>

  <script type="module">
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";
    import {
      collection,
      query,
      orderBy,
      onSnapshot,
      doc,
      setDoc,
      getDoc,
      deleteDoc,
      Timestamp,
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";
    import { getFirebase } from "/components/firebase-init.js";

    // ============================
    // Basic page helpers
    // ============================
    const $ = (id) => document.getElementById(id);

    document.addEventListener("DOMContentLoaded", function () {
      const currentYear = new Date().getFullYear();
      const footerText = `&copy; 2019-${currentYear} Unlim8ted Studio Productions. All rights reserved.`;
      const el = $("footer-text");
      if (el) el.innerHTML = footerText;

      const updateNavSpace = () => {
        const spacer = document.querySelector(".site-navbar-spacer");
        const h = spacer ? spacer.getBoundingClientRect().height : 56;
        document.documentElement.style.setProperty("--navSpace", `${Math.round(h)}px`);
      };
      updateNavSpace();
      window.addEventListener("resize", updateNavSpace, { passive: true });
      setTimeout(updateNavSpace, 250);
    });

    // ============================
    // Epilepsy warning (dismiss)
    // ============================
    const warnEl = $("epWarn");
    const dismissWarnBtn = $("dismissWarn");
    const WARN_KEY = "vizWarnDismissed_v1";

    function showWarnIfNeeded() {
      try {
        const dismissed = localStorage.getItem(WARN_KEY) === "1";
        warnEl.style.display = dismissed ? "none" : "flex";
      } catch {
        warnEl.style.display = "flex";
      }
    }
    dismissWarnBtn.addEventListener("click", () => {
      try { localStorage.setItem(WARN_KEY, "1"); } catch { }
      warnEl.style.display = "none";
    });
    showWarnIfNeeded();

    // ============================
    // Visualizer + playback state
    // ============================
    const canvas = $("midiCanvas");
    const ctx2d = canvas.getContext("2d");

    let notes = [];
    let startTime = null;
    let audio = null;
    let isPlaying = false;
    let durationMs = 0;

    let vizMode = "midi"; // "midi" | "audio"
    let rafId = null;

    // WebAudio analyser for audio mode (also OK for normal tracks)
    let audioCtx = null;
    let analyser = null;
    let srcNode = null;
    let freqData = null;
    let timeData = null;

    const nowPlayingEl = $("nowPlaying");
    const statusChip = $("statusChip");
    const timeChip = $("timeChip");
    const timeline = $("timeline");
    const vizSubtitle = $("vizSubtitle");
    const autoplayNextEl = $("autoplayNext");

    const pauseBtn = $("pauseBtn");
    const playBtn = $("playBtn");
    const restartBtn = $("restartBtn");
    const volumeEl = $("volume");

    const songListEl = $("songList");

    const colorPalette = [
      "#ff00c1", "#9600ff", "#4900ff", "#00b8ff", "#00fff9",
      "#ff7400", "#ffcc00", "#9cff00", "#00ff6b", "#ff003c",
      "#00ffcc", "#3c00ff", "#eaff00", "#ff0074", "#00ff96",
    ];

    function fmtTime(sec) {
      sec = Math.max(0, sec || 0);
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${String(s).padStart(2, "0")}`;
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx2d.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas, { passive: true });
    setTimeout(resizeCanvas, 50);

    function stopRaf() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function ensureAnalyser() {
      if (!audio) return;

      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume().catch(() => { });

      if (srcNode) { try { srcNode.disconnect(); } catch { } srcNode = null; }
      if (!analyser) {
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;
      }

      // IMPORTANT: MediaElementSource is tied to the specific <audio> element instance.
      srcNode = audioCtx.createMediaElementSource(audio);
      srcNode.connect(analyser);
      analyser.connect(audioCtx.destination);

      freqData = new Uint8Array(analyser.frequencyBinCount);
      timeData = new Uint8Array(analyser.fftSize);
    }

    function clearCanvas() {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      ctx2d.clearRect(0, 0, w, h);
    }

    // ===== MIDI "falling notes" =====
    function drawMidiNotes() {
      if (!isPlaying || vizMode !== "midi") return;

      const currentTime = performance.now() - startTime;
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      ctx2d.clearRect(0, 0, w, h);

      const noteWidth = w / 128;

      for (const note of notes) {
        const timeOffset = note.startTime - currentTime;
        const y = h - (timeOffset / 10) - (note.duration / 10);
        const noteHeight = note.duration / 10;

        if (y > h || y + noteHeight < 0) continue;

        const instrumentColor = colorPalette[note.instrument % colorPalette.length];
        const x = note.midi * noteWidth;

        ctx2d.fillStyle = instrumentColor;
        ctx2d.fillRect(x, y, Math.max(1, noteWidth - 2), Math.max(1, noteHeight));
      }

      rafId = requestAnimationFrame(drawMidiNotes);
    }

    // ===== Audio-reactive "cool" visualizer =====
    function drawAudioViz() {
      if (!isPlaying || vizMode !== "audio" || !analyser || !freqData || !timeData) return;

      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;

      analyser.getByteFrequencyData(freqData);
      analyser.getByteTimeDomainData(timeData);

      // Background fade for trails
      ctx2d.fillStyle = "rgba(0,0,0,0.18)";
      ctx2d.fillRect(0, 0, w, h);

      // Energy (0..1-ish)
      let sum = 0;
      for (let i = 0; i < freqData.length; i++) sum += freqData[i];
      const avg = sum / (freqData.length * 255);
      const energy = Math.min(1, Math.max(0, avg * 1.8));

      // Center glow rings
      const cx = w * 0.5;
      const cy = h * 0.5;
      const baseR = Math.min(w, h) * (0.10 + energy * 0.14);
      const rings = 5;

      for (let r = 0; r < rings; r++) {
        const t = (performance.now() * 0.001) + r * 0.35;
        const wobble = (Math.sin(t * 1.7) + Math.cos(t * 1.1)) * 0.5;
        const radius = baseR + r * (18 + energy * 22) + wobble * (8 + energy * 10);

        ctx2d.beginPath();
        ctx2d.arc(cx, cy, Math.max(6, radius), 0, Math.PI * 2);
        const c1 = colorPalette[(r * 3) % colorPalette.length];

        ctx2d.strokeStyle = `rgba(255,255,255,${0.05 + energy * 0.10})`;
        ctx2d.lineWidth = 1 + energy * 2;
        ctx2d.stroke();

        ctx2d.strokeStyle = `${c1}`;
        ctx2d.globalAlpha = 0.05 + energy * 0.18;
        ctx2d.lineWidth = 1 + energy * 2;
        ctx2d.stroke();
        ctx2d.globalAlpha = 1;
      }

      // Spectrum bars
      const bars = Math.min(96, freqData.length);
      const barW = w / bars;
      for (let i = 0; i < bars; i++) {
        const v = freqData[i] / 255;
        const bh = v * (h * 0.45);
        const x = i * barW;
        const y = h - bh;

        const col = colorPalette[i % colorPalette.length];
        ctx2d.globalAlpha = 0.25 + v * 0.65;
        ctx2d.fillStyle = col;
        ctx2d.fillRect(x + 1, y, Math.max(1, barW - 3), bh);
      }
      ctx2d.globalAlpha = 1;

      // Waveform
      ctx2d.beginPath();
      for (let i = 0; i < timeData.length; i++) {
        const v = (timeData[i] - 128) / 128;
        const x = (i / (timeData.length - 1)) * w;
        const y = cy + v * (h * 0.16 + energy * h * 0.08);
        if (i === 0) ctx2d.moveTo(x, y);
        else ctx2d.lineTo(x, y);
      }
      ctx2d.lineWidth = 2;
      ctx2d.strokeStyle = `rgba(233,231,255,${0.35 + energy * 0.45})`;
      ctx2d.stroke();

      rafId = requestAnimationFrame(drawAudioViz);
    }

    function setMode(mode) {
      vizMode = mode;
      stopRaf();
      clearCanvas();
      if (mode === "midi") {
        vizSubtitle.textContent = "MIDI notes falling in real-time.";
        if (isPlaying) drawMidiNotes();
      } else {
        vizSubtitle.textContent = "Audio-reactive mode (spectrum + waveform).";
        if (isPlaying) drawAudioViz();
      }
    }

    function teardownAudio() {
      stopRaf();

      if (audio) {
        try { audio.pause(); } catch { }
        audio.src = "";
        audio.load();
      }
      audio = null;

      if (srcNode) { try { srcNode.disconnect(); } catch { } srcNode = null; }
      // keep analyser/audioCtx for speed
    }

    function setupAudioElement(audioUrl) {
      teardownAudio();

      audio = new Audio(audioUrl);
      audio.crossOrigin = "anonymous";
      audio.volume = parseFloat(volumeEl.value || "1");

      audio.onplay = () => { ensureAnalyser(); };

      audio.ontimeupdate = () => {
        timeline.value = audio.currentTime * 1000;
        timeChip.textContent = fmtTime(audio.currentTime);
      };

      audio.onended = () => {
        isPlaying = false;
        statusChip.textContent = "Ended";
        stopRaf();
        // Auto-play next if enabled
        if (autoplayNextEl.checked) playNext();
      };
    }

    pauseBtn.addEventListener("click", pauseTrack);
    playBtn.addEventListener("click", resumeTrack);
    restartBtn.addEventListener("click", restartTrack);
    volumeEl.addEventListener("input", (e) => setVolume(e));
    timeline.addEventListener("change", (e) => seekTrack(e));

    // ============================
    // Products.json -> build list
    // ============================
    const PRODUCTS_URL = "/tools/data/products.json";

    /** full array from products.json (only "music" items) */
    let allMusic = [];

    /** index currently selected/playing inside allMusic */
    let currentIndex = -1;

    function isMidiTrack(item) {
      return !!(item && item.midi && String(item.midi).trim());
    }

    function displayTitle(item) {
      return (item?.name || "").trim() || "Untitled";
    }

    function safeUrl(u) {
      return String(u || "").trim();
    }

    function clearPlayingHighlight() {
      const prev = songListEl.querySelector(".song-item.playing");
      if (prev) prev.classList.remove("playing");
    }

    function setPlayingHighlight(index) {
      clearPlayingHighlight();
      const el = songListEl.querySelector(`.song-item[data-index="${index}"]`);
      if (el) {
        el.classList.add("playing");
        // keep visible (especially when autoplaying)
        el.scrollIntoView({ block: "nearest", behavior: "smooth" });
      }
    }

    function buildSongItem(item, index) {
      const wrap = document.createElement("div");
      wrap.className = "song-item";
      wrap.dataset.index = String(index);

      const name = document.createElement("div");
      name.className = "song-name";

      // If it's TimeCat-style, keep the name as-is (you can encode TRACK numbers in name if you want)
      name.textContent = displayTitle(item);

      const actions = document.createElement("div");
      actions.className = "song-actions";

      // PDF button (only if present)
      if (item.pdf) {
        const a = document.createElement("a");
        a.className = "pill";
        a.href = safeUrl(item.pdf);
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = "View PDF";
        actions.appendChild(a);
      }

      // Play button
      const play = document.createElement("span");
      play.className = "pill pill-btn";
      play.textContent = "Play";
      play.addEventListener("click", (e) => {
        e.stopPropagation();
        playByIndex(index);
      });
      actions.appendChild(play);

      wrap.addEventListener("click", () => playByIndex(index));

      wrap.appendChild(name);
      wrap.appendChild(actions);
      return wrap;
    }

    function buildDivider(kicker, title, sub) {
      const d = document.createElement("div");
      d.className = "section-divider";

      const k = document.createElement("div");
      k.className = "section-kicker";
      k.textContent = kicker;

      const t = document.createElement("div");
      t.className = "section-title";
      t.textContent = title;

      const s = document.createElement("div");
      s.className = "section-sub";
      s.textContent = sub;

      d.appendChild(k);
      d.appendChild(t);
      d.appendChild(s);
      return d;
    }

    function inferIsTimecat(item) {
      // No special flag in JSON, so infer by path or lack of midi (you can change this any time)
      const file = safeUrl(item.file);
      return file.includes("/products/games/TimeCat/") || file.includes("/TimeCat/");
    }

    function renderSongList() {
      songListEl.innerHTML = "";

      const normal = allMusic.filter(i => isMidiTrack(i));
      const timecat = allMusic.filter(i => !isMidiTrack(i) && inferIsTimecat(i));
      const otherAudio = allMusic.filter(i => !isMidiTrack(i) && !inferIsTimecat(i));

      if (!normal.length && !timecat.length && !otherAudio.length) {
        songListEl.innerHTML = `<div class="empty">No tracks found in products.json.</div>`;
        return;
      }

      if (normal.length) {
        const d = buildDivider("Library", "Scores + MIDI", "MIDI + MP3 with falling-note visuals and optional PDFs.");
        songListEl.appendChild(d);
        normal.forEach(item => {
          const idx = allMusic.indexOf(item);
          songListEl.appendChild(buildSongItem(item, idx));
        });
      }

      if (timecat.length) {
        const d = buildDivider("Soundtrack", "TimeCat", "The soundracks to Unlim8ted's newest game in development, Time Cat.");
        songListEl.appendChild(d);
        timecat.forEach(item => {
          const idx = allMusic.indexOf(item);
          songListEl.appendChild(buildSongItem(item, idx));
        });
      }

      if (otherAudio.length) {
        const d = buildDivider("Audio", "Other Tracks", "Audio-only tracks with reactive visuals.");
        songListEl.appendChild(d);
        otherAudio.forEach(item => {
          const idx = allMusic.indexOf(item);
          songListEl.appendChild(buildSongItem(item, idx));
        });
      }

      // restore highlight if something is selected
      if (currentIndex >= 0) setPlayingHighlight(currentIndex);
    }

    async function loadProducts() {
      try {
        const res = await fetch(PRODUCTS_URL, { cache: "no-store" });
        if (!res.ok) throw new Error(`Failed to load products.json (${res.status})`);
        const json = await res.json();

        // Keep only music
        allMusic = Array.isArray(json) ? json.filter(p => p && p["product-type"] === "music") : [];
        renderSongList();

        // If you want: auto-select first track without playing
        if (allMusic.length && currentIndex < 0) {
          setActiveProduct(0, { autoplay: false, keepStatus: true });
        }
      } catch (e) {
        console.error("products load error:", e);
        songListEl.innerHTML = `<div class="empty">Could not load <b>/tools/data/products.json</b>.</div>`;
      }
    }

    // ============================
    // Play by item (from JSON)
    // ============================
    async function playByIndex(index) {
      index = Number(index);
      if (!Number.isFinite(index) || index < 0 || index >= allMusic.length) return;

      setActiveProduct(index, { autoplay: true, keepStatus: false });
    }

    function playNext() {
      if (!allMusic.length) return;
      const next = (currentIndex >= 0) ? (currentIndex + 1) % allMusic.length : 0;
      // autoplay next
      setActiveProduct(next, { autoplay: true, keepStatus: false });
    }

    async function setActiveProduct(index, opts = { autoplay: true, keepStatus: false }) {
      const item = allMusic[index];
      if (!item) return;

      currentIndex = index;
      setPlayingHighlight(index);

      // Update "now playing" line immediately
      const title = displayTitle(item);
      nowPlayingEl.textContent = opts.autoplay ? `Now playing: ${title}` : `Selected: ${title}`;

      // Switch reviews/rating context to this product id
      activateReviewsFor(item);

      // Start playback (or just prepare)
      if (isMidiTrack(item)) {
        await playMidiAndAudio(item, title, opts.autoplay);
      } else {
        await playAudioOnly(item, title, opts.autoplay);
      }
    }

    // Normal track (MIDI + MP3)
    async function playMidiAndAudio(item, title, autoplay = true) {
      const midiFileUrl = safeUrl(item.midi);
      const audioFileUrl = safeUrl(item.file);

      statusChip.textContent = autoplay ? "Loading…" : "Ready";
      setMode("midi");

      // Reset timeline to avoid weird jump
      timeline.value = 0;
      timeline.max = 100;

      try {
        const r = await fetch(midiFileUrl);
        const data = await r.arrayBuffer();
        const midi = new Midi(data);

        notes = midi.tracks.flatMap((track, index) =>
          track.notes.map(n => ({
            midi: n.midi,
            startTime: n.time * 1000,
            duration: n.duration * 1000,
            instrument: index
          }))
        );

        durationMs = midi.duration * 1000;
        timeline.max = durationMs;
        timeline.value = 0;

        resizeCanvas();
        setupAudioElement(audioFileUrl);

        audio.onloadedmetadata = () => {
          // If the MP3 duration differs, timeline still works (we keep durationMs from MIDI for visuals)
          if (!durationMs && audio.duration) timeline.max = audio.duration * 1000;
        };

        startTime = performance.now();

        if (!autoplay) {
          isPlaying = false;
          statusChip.textContent = "Ready";
          clearCanvas();
          return;
        }

        await audio.play();
        isPlaying = true;
        statusChip.textContent = "Playing";
        drawMidiNotes();
      } catch (err) {
        console.error("Error loading/playing MIDI track:", err);
        isPlaying = false;
        statusChip.textContent = "Error";
        nowPlayingEl.textContent = "Could not load MIDI/audio";
      }
    }

    // TimeCat / audio-only track
    async function playAudioOnly(item, title, autoplay = true) {
      const audioFileUrl = safeUrl(item.file);

      statusChip.textContent = autoplay ? "Loading…" : "Ready";
      setMode("audio");
      resizeCanvas();

      // duration unknown until metadata loads
      durationMs = 0;
      timeline.value = 0;
      timeline.max = 100;

      setupAudioElement(audioFileUrl);

      audio.onloadedmetadata = () => {
        durationMs = (audio.duration || 0) * 1000;
        if (durationMs > 0) timeline.max = durationMs;
      };

      startTime = performance.now();

      if (!autoplay) {
        isPlaying = false;
        statusChip.textContent = "Ready";
        clearCanvas();
        return;
      }

      try {
        await audio.play();
        isPlaying = true;
        statusChip.textContent = "Playing";
        drawAudioViz();
      } catch (err) {
        console.error("Error playing audio-only track:", err);
        isPlaying = false;
        statusChip.textContent = "Error";
        nowPlayingEl.textContent = "Playback error";
      }
    }

    // ============================
    // Controls
    // ============================
    function pauseTrack() {
      if (audio && isPlaying) {
        audio.pause();
        isPlaying = false;
        statusChip.textContent = "Paused";
        stopRaf();
      }
    }

    function resumeTrack() {
      if (audio && !isPlaying) {
        audio.play().then(() => {
          isPlaying = true;
          statusChip.textContent = "Playing";
          startTime = performance.now() - (audio.currentTime * 1000);
          if (vizMode === "midi") drawMidiNotes();
          else drawAudioViz();
        }).catch(() => { });
      }
    }

    function restartTrack() {
      if (!audio) return;
      audio.currentTime = 0;
      timeline.value = 0;
      startTime = performance.now();

      if (!isPlaying) {
        audio.play().then(() => {
          isPlaying = true;
          statusChip.textContent = "Playing";
          if (vizMode === "midi") drawMidiNotes();
          else drawAudioViz();
        }).catch(() => { });
      } else {
        statusChip.textContent = "Playing";
        stopRaf();
        if (vizMode === "midi") drawMidiNotes();
        else drawAudioViz();
      }
    }

    function seekTrack(event) {
      const seekTime = Number(event.target.value || 0);
      if (!audio) return;

      audio.currentTime = seekTime / 1000;
      startTime = performance.now() - seekTime;

      if (isPlaying) {
        stopRaf();
        if (vizMode === "midi") drawMidiNotes();
        else drawAudioViz();
      }
    }

    function setVolume(event) {
      if (audio) audio.volume = parseFloat(event.target.value);
    }

    // ============================
    // Reviews / ratings (Firestore)
    // products/{productId}/comments
    // ============================
    const { auth, db } = getFirebase();

    // --- DOM (comments/ratings)
    const avgNum = $("avgNum");
    const avgLabel = $("avgLabel");
    const countLabel = $("countLabel");
    const avgStars = $("avgStars");
    const avgStarsBig = $("avgStarsBig");
    const barsEl = $("bars");

    const commentList = $("commentList");
    const commentForm = $("commentForm");
    const mustSignIn = $("mustSignIn");
    const ratingSel = $("ratingSel");
    const displayNameInput = $("displayName");
    const commentText = $("commentText");
    const formMsg = $("formMsg");
    const deleteMyReviewBtn = $("deleteMyReviewBtn");
    const postBtn = $("postBtn");

    function starsText(value) {
      const v = Math.max(0, Math.min(5, value));
      let out = "";
      for (let i = 1; i <= 5; i++) out += (i <= Math.round(v)) ? "★" : "☆";
      return out;
    }

    function renderBars(counts, total) {
      barsEl.innerHTML = "";
      for (let star = 5; star >= 1; star--) {
        const n = counts[star] || 0;
        const pct = total > 0 ? (n / total) * 100 : 0;

        const row = document.createElement("div");
        row.className = "barRow";

        const left = document.createElement("div");
        left.textContent = `${star} star`;

        const track = document.createElement("div");
        track.className = "barTrack";

        const fill = document.createElement("div");
        fill.className = "barFill";
        fill.style.width = `${pct.toFixed(1)}%`;

        const right = document.createElement("div");
        right.style.textAlign = "right";
        right.textContent = String(n);

        track.appendChild(fill);
        row.appendChild(left);
        row.appendChild(track);
        row.appendChild(right);
        barsEl.appendChild(row);
      }
    }

    function renderComments(docs, uid) {
      commentList.innerHTML = "";

      if (!docs.length) {
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.textContent = "No reviews yet. Be the first.";
        commentList.appendChild(empty);
        return;
      }

      docs.forEach(d => {
        const data = d.data();
        const rating = Number(data.rating || 0);
        const text = (data.text || "").trim();
        const who = (data.displayName || "").trim() || "Anonymous";

        let when = "";
        const ts = data.createdAt;
        if (ts && typeof ts.toDate === "function") when = ts.toDate().toLocaleString();

        const el = document.createElement("div");
        el.className = "comment";

        const top = document.createElement("div");
        top.className = "commentTop";

        const whoEl = document.createElement("div");
        whoEl.className = "who";
        whoEl.style.color = "#ffcc66";
        whoEl.textContent = `${who} • ${starsText(rating)}`;

        if (uid && d.id === uid) {
          const badge = document.createElement("span");
          badge.className = "mineBadge";
          badge.textContent = "Yours";
          whoEl.appendChild(badge);
        }

        const whenEl = document.createElement("div");
        whenEl.className = "when";
        whenEl.textContent = when;

        const p = document.createElement("p");
        p.className = "commentText";
        p.textContent = text;

        top.appendChild(whoEl);
        top.appendChild(whenEl);
        el.appendChild(top);
        el.appendChild(p);
        commentList.appendChild(el);
      });
    }

    function setFormBusy(busy) {
      postBtn.disabled = busy;
      deleteMyReviewBtn.disabled = busy;
      ratingSel.disabled = busy;
      displayNameInput.disabled = busy;
      commentText.disabled = busy;
    }

    function showFormMessage(msg, isError = false) {
      formMsg.textContent = msg || "";
      formMsg.style.color = isError ? "rgba(255,120,120,.95)" : "rgba(255,255,255,.65)";
    }

    // State for reviews
    let currentUid = null;
    let myReviewCache = null;
    let unsubComments = null;

    // Track which product's comments are active
    let activeProductId = null;

    // One auth listener for the whole page
    onAuthStateChanged(auth, async (user) => {
      currentUid = user ? user.uid : null;

      if (user) {
        mustSignIn.style.display = "none";
        commentForm.style.display = "grid";
        displayNameInput.value = user.displayName || "";
      } else {
        myReviewCache = null;
        commentForm.style.display = "none";
        mustSignIn.style.display = "block";
        deleteMyReviewBtn.style.display = "none";
        showFormMessage("");
      }

      // Reload "my review" when auth state changes for current product
      if (activeProductId) {
        await loadMyReviewFor(activeProductId);
      }
    });

    async function loadMyReviewFor(productId) {
      const user = auth.currentUser;
      if (!user) {
        myReviewCache = null;
        deleteMyReviewBtn.style.display = "none";
        showFormMessage("");
        return;
      }

      try {
        const myRef = doc(db, "products", String(productId), "comments", user.uid);
        const mySnap = await getDoc(myRef);

        if (mySnap.exists()) {
          myReviewCache = mySnap.data();
          ratingSel.value = String(myReviewCache.rating || "5");
          displayNameInput.value = (myReviewCache.displayName || "").trim() || (user.displayName || "");
          commentText.value = (myReviewCache.text || "").trim();
          deleteMyReviewBtn.style.display = "inline-block";
          showFormMessage("Editing your review.");
        } else {
          myReviewCache = null;
          ratingSel.value = "5";
          displayNameInput.value = user.displayName || "";
          commentText.value = "";
          deleteMyReviewBtn.style.display = "none";
          showFormMessage("");
        }
      } catch (e) {
        console.error("load my review error:", e?.code, e?.message, e);
        myReviewCache = null;
        deleteMyReviewBtn.style.display = "none";
        showFormMessage("");
      }
    }

    function activateReviewsFor(item) {
      const productId = String(item?.id || "");
      if (!productId) return;

      activeProductId = productId;

      // Reset UI immediately
      avgNum.textContent = "—";
      avgLabel.textContent = "Loading ratings…";
      countLabel.textContent = "";
      avgStars.textContent = "☆☆☆☆☆";
      avgStarsBig.textContent = "☆☆☆☆☆";
      barsEl.innerHTML = "";
      commentList.innerHTML = `<div class="empty">Loading reviews…</div>`;
      showFormMessage("");
      deleteMyReviewBtn.style.display = "none";

      // Kill old listener
      if (unsubComments) { try { unsubComments(); } catch { } unsubComments = null; }

      // Start new listener
      const commentsRef = collection(db, "products", productId, "comments");
      const commentsQ = query(commentsRef, orderBy("createdAt", "desc"));

      unsubComments = onSnapshot(
        commentsQ,
        (snap) => {
          const docs = snap.docs;
          const total = docs.length;
          let sum = 0;
          const counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };

          for (const d of docs) {
            const r = Number(d.data().rating || 0);
            if (r >= 1 && r <= 5) {
              sum += r;
              counts[r] = (counts[r] || 0) + 1;
            }
          }

          const avg = total ? sum / total : 0;
          avgNum.textContent = total ? avg.toFixed(1) : "—";
          avgLabel.textContent = total ? "Average rating" : "No ratings yet";
          countLabel.textContent = `${total} review${total === 1 ? "" : "s"}`;
          avgStars.textContent = starsText(avg);
          avgStarsBig.textContent = starsText(avg);

          renderBars(counts, total);
          renderComments(docs, currentUid);
        },
        (err) => {
          console.error("Comments listener error:", err?.code, err?.message, err);
          commentList.innerHTML = `<div class="empty">Reviews unavailable.</div>`;
          avgLabel.textContent = "Reviews unavailable";
        }
      );

      // Load my review state (if signed in)
      loadMyReviewFor(productId);
    }

    // Post/edit review
    commentForm.onsubmit = async (e) => {
      e.preventDefault();
      const user = auth.currentUser;
      if (!user || !activeProductId) return;

      const rating = Math.trunc(parseInt(ratingSel.value, 10) || 0);
      const text = commentText.value.trim();
      const rawName = displayNameInput.value.trim();
      const finalName = rawName ? rawName : "Anonymous";

      if (!text) { showFormMessage("Please write a comment.", true); return; }
      if (text.length > 2000) { showFormMessage("Comment is too long (max 2000 chars).", true); return; }
      if (rating < 1 || rating > 5) { showFormMessage("Please select a rating 1–5.", true); return; }
      if (finalName.length > 80) { showFormMessage("Name too long (max 80 chars).", true); return; }

      showFormMessage("Saving…");
      setFormBusy(true);

      try {
        const myRef = doc(db, "products", String(activeProductId), "comments", user.uid);
        const existing = await getDoc(myRef);

        if (existing.exists()) {
          await setDoc(myRef, { rating, text, displayName: finalName }, { merge: true });
        } else {
          await setDoc(myRef, {
            userId: user.uid,
            rating,
            text,
            displayName: finalName,
            createdAt: Timestamp.now(),
          });
        }

        const snap = await getDoc(myRef);
        myReviewCache = snap.exists() ? snap.data() : null;

        deleteMyReviewBtn.style.display = myReviewCache ? "inline-block" : "none";
        showFormMessage("Saved");
        setTimeout(() => showFormMessage(myReviewCache ? "Editing your review." : ""), 900);
      } catch (err) {
        console.error("save review error:", err?.code, err?.message, err);
        showFormMessage("Failed to save review.", true);
      } finally {
        setFormBusy(false);
      }
    };

    // Delete my review
    deleteMyReviewBtn.onclick = async () => {
      const user = auth.currentUser;
      if (!user || !activeProductId) return;
      if (!confirm("Delete your review?")) return;

      showFormMessage("Deleting…");
      setFormBusy(true);

      try {
        const myRef = doc(db, "products", String(activeProductId), "comments", user.uid);
        await deleteDoc(myRef);

        myReviewCache = null;
        ratingSel.value = "5";
        displayNameInput.value = user.displayName || "";
        commentText.value = "";
        deleteMyReviewBtn.style.display = "none";
        showFormMessage("Deleted");
        setTimeout(() => showFormMessage(""), 900);
      } catch (err) {
        console.error("delete review error:", err?.code, err?.message, err);
        showFormMessage("Failed to delete.", true);
      } finally {
        setFormBusy(false);
      }
    };

    // ============================
    // Boot
    // ============================
    await loadProducts();

    // Expose a tiny API (optional; list uses internal click listeners anyway)
    window.playByIndex = playByIndex;
  </script>
</body>

</html>
